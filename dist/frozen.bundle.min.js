/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var frozen = {
	  GameCore : __webpack_require__(1),
	  InputManager : __webpack_require__(2),
	  ResourceManager : __webpack_require__(9),
	  MouseAction : __webpack_require__(6),
	  TouchAction : __webpack_require__(5),
	  keys : __webpack_require__(8),
	  Animation: __webpack_require__(15),
	  AnimFrame: __webpack_require__(16),
	  utils : __webpack_require__(17),
	  Sprite : __webpack_require__(27),
	  reiner : {
	    Creature : __webpack_require__(28)
	  },
	  sounds : {
	    WebAudio : __webpack_require__(13)
	  },
	  box2d : {
	    entities : __webpack_require__(29),
	    joints: __webpack_require__(35),
	    Box : __webpack_require__(40),
	    BoxGame : __webpack_require__(42)
	  }

	};

	module.exports = frozen;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * The GameCore class provides the base to build games on.
	 * @name GameCore
	 * @constructor GameCore
	 * @example
	 * var myGame = new GameCore({
	 *   canvasId: 'myCanvas',
	 *   update: function(millis){
	 *     // do updating of game state
	 *   },
	 *   draw: function(context){
	 *     // do drawing of the game
	 *   }
	 * });
	 *
	 * //start the game
	 * myGame.run();
	 */

	const InputManager = __webpack_require__(2);
	const ResourceManager = __webpack_require__(9);

	class GameCore {

	  constructor(options = {}){

	    /**
	     * Whether or not the game should be running its loop
	     * @type {Boolean}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.isRunning = false;

	    /**
	     * The id of the canvas element to use render the game on
	     * @type {String}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.canvasId = null;

	    /**
	     * Max number of milliseconds between updates. (in case user switches tabs and requestAnimationFrame pauses)
	     * @type {Number}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.maxStep = 40;

	    /**
	     * The type of context to request from the canvas.  2d or 3d
	     * @type {String}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.contextType = '2d';

	    /**
	     * The height of the Game and canvas
	     * @type {Number}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.height = 0;

	    /**
	     * The width of the Game and canvas
	     * @type {Number}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.width = 0;

	    /**
	     * The ResourceManager to be used for game
	     * @type {ResourceManager}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.resourceManager = null;

	    /**
	     * The InputManager to be used for game
	     * @type {InputManager}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.inputManager = null;

	    /**
	     * The style to be used for the foreground while game resources are loading
	     * @type {String}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.loadingForeground = '#00F';

	    /**
	     * The style to be used for the background while game resources are loading
	     * @type {String}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.loadingBackground = '#FFF';

	    /**
	     * The ID of a DOM element that contains the game's canvas
	     * @type {String}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.gameAreaId = null;

	    /**
	     * The percentage (0 to 1.0) of the height and width the canvas should use to fill in its container DOM element
	     * @type {Number}
	     * @memberOf GameCore#
	     * @default
	     */
	    this.canvasPercentage = 0;

	    Object.assign(this, options);

	    if(!this.resourceManager){
	      this.resourceManager = new ResourceManager();
	    }
	  }

	  /**
	   * Sets the height on your GameCore instance and on your canvas reference
	   * @function
	   * @memberOf GameCore#
	   * @param {Number} newHeight The new height desired
	   */
	  setHeight(newHeight){
	    this.height = newHeight;
	    this.canvas.height = newHeight;
	  }

	  /**
	   * Sets the width on your GameCore instance and on your canvas reference
	   * @function
	   * @memberOf GameCore#
	   * @param {Number} newWidth The new width desired
	   */
	  setWidth(newWidth){
	    this.width = newWidth;
	    this.canvas.width = newWidth;
	  }

	  /**
	   * Signals the game loop that it's time to quit
	   * @function
	   * @memberOf GameCore#
	   */
	  stop() {
	    this.isRunning = false;
	  }

	  /**
	   * Launches the game.
	   * @function
	   * @memberOf GameCore#
	   */
	  run() {
	    if(!this.isRunning){
	      this.init();
	      this.loadResources(this.resourceManager);
	      this.initInput(this.inputManager);
	      this.launchLoop();
	    }
	  }

	  /**
	   * Can be overidden in GameCore subclasses to load images and sounds
	   * @function
	   * @memberOf GameCore#
	   * @param {ResourceManager} resourceManager
	   */
	  loadResources(resourceManager){

	  }

	  /**
	   * Sets the screen mode and initiates and objects.
	   * @function
	   * @memberOf GameCore#
	   */
	  init() {
	    if(!this.canvas){
	      this.canvas = document.getElementById(this.canvasId);
	    }
	    if(!this.canvas){
	      
	      alert('Sorry, your browser does not support canvas.  I recommend any browser but Internet Explorer');
	      return;
	    }
	    if(!this.context){
	      this.context = this.canvas.getContext(this.contextType);
	    }
	    if(!this.context){
	      alert('Sorry, your browser does not support a ' + this.contextType + ' drawing surface on canvas.  I recommend any browser but Internet Explorer');
	      return;
	    }

	    this.setHeight(this.height || this.canvas.height);
	    this.setWidth(this.width || this.canvas.width);

	    if(!this.inputManager){
	      //handle resizing if gameArea and canvasPercentage are specified
	      if(this.gameAreaId && this.canvasPercentage){
	        this.inputManager = new InputManager({
	          canvas: this.canvas,
	          gameArea: document.getElementById(this.gameAreaId),
	          canvasPercentage: this.canvasPercentage
	        });
	      }else{
	        this.inputManager = new InputManager({
	          canvas: this.canvas
	        });
	      }
	    }

	    this.inputManager.resize();

	    this.isRunning = true;
	  }

	  /**
	   * Can be overidden in the subclasses to map user input to actions
	   * @function
	   * @memberOf GameCore#
	   * @param {InputManager} inputManager
	   */
	  initInput(inputManager) {

	  }

	  /**
	   * Can be overidden in the subclasses to deal with user input before updating the game state
	   * @function
	   * @memberOf GameCore#
	   * @param {InputManager} inputManager
	   * @param {Number} elapsedTime Elapsed time in milliseconds
	   */
	  handleInput(inputManager,elapsedTime) {

	  }

	  /**
	   * Runs through the game loop until stop() is called.
	   * @function
	   * @memberOf GameCore#
	   */
	  gameLoop() {
	    this.currTime = new Date().getTime();
	    this.elapsedTime = Math.min(this.currTime - this.prevTime, this.maxStep);
	    this.prevTime = this.currTime;

	    //it's using a resource manager, but resources haven't finished
	    if(this.resourceManager && !this.resourceManager.resourcesReady()){
	      this.updateLoadingScreen(this.elapsedTime);
	      this.drawLoadingScreen(this.context);
	    } else {
	      this.handleInput(this.inputManager,this.elapsedTime);
	      if(!this.paused){
	        // update
	        this.update(this.elapsedTime);
	      }
	      // draw the screen
	      this.context.save();
	      this.draw(this.context);
	      this.context.restore();
	    }
	  }

	  /**
	   * Launches the game loop.
	   * @function
	   * @memberOf GameCore#
	   */
	  launchLoop(){
	    this.elapsedTime = 0;
	    var startTime = Date.now();
	    this.currTime = startTime;
	    this.prevTime = startTime;

	    //need to keep the context defined here so the game loop has access to it
	    this.loopRunner = this.loopRunner.bind(this);
	    window.requestAnimationFrame(this.loopRunner);
	  }

	  loopRunner(){
	    this.gameLoop();
	    window.requestAnimationFrame(this.loopRunner);
	  }

	  /**
	   * Should be overridden to update the state of the game/animation based on the amount of elapsed time that has passed.
	   * @function
	   * @memberOf GameCore#
	   * @param {Number} elapsedTime Elapsed time in milliseconds
	   */
	  update(elapsedTime) {


	  }

	  /**
	   * Can be overridden to update the state of the game/animation while a custom loading screen is displayed.
	   * @function
	   * @memberOf GameCore#
	   * @param {Number} elapsedTime Elapsed time in milliseconds
	   */
	  updateLoadingScreen(elapsedTime) {

	  }

	  /**
	   * Draws to the screen. Subclasses or instances must override this method to paint items to the screen.
	   * @function
	   * @memberOf GameCore#
	   * @param {Context} context An HTML5 canvas drawing context.
	   */
	  draw(context){
	    if(this.contextType === '2d'){
	      context.font = "14px sans-serif";
	      context.fillText("This game does not have its own draw function!", 10, 50);
	    }
	  }

	  /**
	   * Draws the progress of the resource manger to the screen while loading.
	   * Subclasses or instances may override for custom loading animations.
	   * @function
	   * @memberOf GameCore#
	   * @param {Context} context An HTML5 canvas drawing context.
	   */
	  drawLoadingScreen(context){
	    if(this.resourceManager && (this.contextType === '2d')){
	      context.fillStyle = this.loadingBackground;
	      context.fillRect(0,0, this.width,this.height);

	      context.fillStyle = this.loadingForeground;
	      context.strokeStyle = this.loadingForeground;

	      var textPxSize = Math.floor(this.height/12);

	      context.font = "bold " + textPxSize + "px sans-serif";

	      context.fillText("Loading... " + this.resourceManager.getPercentComplete() + "%", this.width * 0.1, this.height * 0.55);

	      context.strokeRect(this.width * 0.1, this.height * 0.7, this.width * 0.8, this.height * 0.1);
	      context.fillRect(this.width * 0.1, this.height * 0.7, (this.width * 0.8) * this.resourceManager.getPercentComplete()/100, this.height * 0.1);

	      context.lineWidth = 4;
	    }
	  }

	}

	module.exports = GameCore;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * The InputManager handles DOM events for use in games.
	 * @name InputManager
	 * @constructor InputManager
	 */

	const Hammer = __webpack_require__(3);

	const GameAction = __webpack_require__(4);
	const TouchAction = __webpack_require__(5);
	const MouseAction = __webpack_require__(6);
	const insideCanvas = __webpack_require__(7);
	const keys = __webpack_require__(8);

	function on (element, name, handler) {
	  element.addEventListener(name, handler);
	  return function remove() {
	    element.removeEventListener(name, handler);
	  }
	}

	function position(node){
	  var boundingRect = node.getBoundingClientRect();
	  return {
	    x: boundingRect.left,
	    y: boundingRect.top
	  };
	}

	function getComputedStyle(node){
	  return window.getComputedStyle(node, null) || {};
	}

	function toPixel(value){
	  return parseFloat(value) || 0;
	}

	function getMarginExtents(node){
	  var style = getComputedStyle(node);
	  var l = toPixel(style.marginLeft);
	  var t = toPixel(style.marginTop);
	  var r = toPixel(style.marginRight);
	  var b = toPixel(style.marginBottom);
	  return {
	    w: l + r,
	    h: t + b
	  };
	}

	class InputManager {
	  constructor(options = {}){

	    /**
	     * Object of keyActions being listened for
	     * @type {Array}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.keyActions = null;

	    /**
	     * The MouseAction to keep track of the mouse's state
	     * @type {MouseAction}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.mouseAction = null;

	    /**
	     * The TouchAction to keep track of touch events
	     * @type {TouchAction}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.touchAction = null;

	    /**
	     * The HTML5 canvas on which to listen for events
	     * @type {Canvas}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.canvas = null;

	    /**
	     * Whether or not to listen for mouse events
	     * @type {Boolean}
	     * @memberOf InputManager#
	     * @default
	     * @deprecated Mouse is always handled, use emulateMouse to specify how to handle it
	     */
	    this.handleMouse = true;

	    /**
	     * Whether or not to listen for touch events
	     * @type {Boolean}
	     * @memberOf InputManager#
	     * @default
	     * @deprecated Touch is always handled, use emulateMouse to specify how to handle it
	     */
	    this.handleTouch = true;

	    /**
	     * Whether or not to listen for keyboard events
	     * @type {Boolean}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.handleKeys = true;

	    /**
	     * The DOM element that contains the game's canvas
	     * @type {Element}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.gameArea = null;

	    /**
	     * The percentage (0 to 1.0) of the height and width the canvas should use to fill in its container DOM element
	     * @type {Number}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.canvasPercentage = null;

	    /**
	     * Emulate mouse events when using touch
	     * @type {Boolean}
	     * @memberOf InputManager#
	     * @default
	     */
	    this.emulateMouse = true;

	    /**
	     * Instance of Hammer.js - You can pass in a Hammer() constructor with options to customize your Hammer instance
	     * @type {Object}
	     * @memberOf InputManager#
	     * @default Hammer instance, bound to document, with prevent_default: true, drag_max_touches: 0, and hold: false
	     */
	    this.hammer = null;

	    Object.assign(this, options);

	    if(!this.hammer){
	      this.hammer = new Hammer(document.body, {
	        prevent_default: true,
	        drag_max_touches: 0,
	        // Hold uses setTimeout which is very bad for performance
	        // TODO: Do we want to allow this to be overridden?
	        hold: false
	      });
	    }

	    if(!this.keyActions){
	      this.keyActions = {};
	    }

	    function cleanup(handler){
	      handler.remove();
	    }

	    if(this.handleKeys){
	      this.pushCleanup(on(document, 'keydown', this.keydown.bind(this)), cleanup);
	      this.pushCleanup(on(document, 'keyup', this.keyup.bind(this)), cleanup);
	    }

	    if('ontouchstart' in document){
	      this.pushCleanup(on(document, 'touchstart', this.touchstart.bind(this)), cleanup);
	      this.pushCleanup(on(document, 'touchmove', this.touchmove.bind(this)), cleanup);
	      this.pushCleanup(on(document, 'touchend', this.touchend.bind(this)), cleanup);

	    }
	    else{
	      this.pushCleanup(on(document, 'mousedown', this.mousedown.bind(this)), cleanup);
	      this.pushCleanup(on(document, 'mousemove', this.mousemove.bind(this)), cleanup);
	      this.pushCleanup(on(document, 'mouseup', this.mouseup.bind(this)), cleanup);
	    }


	    if(!this.mouseAction){
	      this.mouseAction = new MouseAction();
	    }

	    if(!this.touchAction){
	      this.touchAction = new TouchAction();
	    }

	    if(this.emulateMouse){

	      //da hell hammer, gotta do this oursevles now?

	      // this.on('touch', this.mousedown.bind(this));
	      // this.on('drag', this.mousemove.bind(this));
	      // this.on('release', this.mouseup.bind(this));

	    } else {

	      //da hell hammer, gotta do this oursevles now?
	      // this.on('touch', this.touchstart.bind(this));
	      // this.on('drag', this.touchmove.bind(this));
	      // this.on('release', this.touchend.bind(this));

	    }

	    if(this.gameArea && this.canvasPercentage){
	      var handler = this.resize.bind(this);

	      // Listen for resize changes

	      this.pushCleanup(on(window, 'resize', handler), cleanup);
	      this.pushCleanup(on(window, 'orientationchange', handler), cleanup);
	    }

	    this.normalizePoint = this.normalizePoint.bind(this);
	    this.insideCanvas = this.insideCanvas.bind(this);
	  }

	  /**
	   * Allows you to bind other Hammer.js events (such as Swipe or Doubletap);
	   * Warning: Only set flags or variables in this handler, otherwise your game might become slow
	   * @function
	   * @memberOf InputManager#
	   * @param  {String} gesture The gesture to bind
	   * @param  {Function} handler Event handler callback
	   * @return {Object} Object containing the remove function for removing the event.
	   */
	  on(gesture, handler){
	    var hammer = this.hammer;
	    var removeCleanup = this.removeCleanup;

	    hammer.on(gesture, handler);
	    var cleanup = this.pushCleanup([gesture, handler], function(args){
	      hammer.off.apply(hammer, args);
	    });

	    return {
	      remove: function(){
	        removeCleanup(cleanup);
	        cleanup();
	      }
	    };
	  }

	  /**
	   * Determine whether a point is within the InputManager's canvas
	   * @function
	   * @memberOf InputManager#
	   * @param  {Point} point Point to test
	   * @return {Boolean} Whether or not the point is inside this InputManager's canvas
	   */
	  insideCanvas(point){
	    return insideCanvas(point, this.canvas);
	  }

	  /**
	   * Maps a GameAction to a specific key. The key codes are defined in dojo.keys.
	   * If the key already has a GameAction mapped to it, the new GameAction overwrites it.
	   * @function
	   * @memberOf InputManager#
	   * @param {GameAction} gameAction the GameAction to map
	   * @param {Object} keyCode dojo.keys key code, or character
	   */
	  mapToKey(gameAction, keyCode){
	    this.keyActions[keyCode] = gameAction;
	  }

	  /**
	   * Adds a GameAction to a key
	   * @function
	   * @memberOf InputManager#
	   * @param {Object} keyCode Key character or dojo/keys key code
	   * @param {Boolean=} initialPressOnly Do only one fire of the action per keypress
	   * @return {GameAction} GameAction that is mapped to keyCode
	   */
	  addKeyAction(keyCode, initialPressOnly){
	    var ga = new GameAction();
	    if(initialPressOnly){
	      ga.behavior = ga.detectInitialPressOnly;
	    }
	    this.mapToKey(ga,keyCode);

	    return ga;
	  }

	  /**
	   * Adds arrow key GameActions
	   * @function
	   * @memberOf InputManager#
	   */
	  addArrowKeyActions(){
	    this.addKeyAction(keys.UP);
	    this.addKeyAction(keys.DOWN);
	    this.addKeyAction(keys.LEFT);
	    this.addKeyAction(keys.RIGHT);
	  }

	  /**
	   * Called upon mouseup event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  mouseUp(e) {
	    this.mouseup(e);
	  }

	  /**
	   * Called upon mouseup event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  mouseup(e){
	    this.mouseAction.release(this.normalizePoint(e));
	  }

	  /**
	   * Called upon mousedown event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  mouseDown(e){
	    this.mousedown(e);
	  }

	  /**
	   * Called upon mousedown event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  mousedown(e){
	    // Ensure mouse has been released
	    this.mouseAction.release(null);
	    var currentPoint = this.normalizePoint(e);
	    this.mouseAction.insideCanvas = this.insideCanvas(currentPoint);
	    this.mouseAction.press(currentPoint);
	  }


	  /**
	   * Called upon mousemove event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  mouseMove(e){
	    this.mousemove(e);
	  }

	  /**
	   * Called upon mousemove event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  mousemove(e){
	    this.mouseAction.position = this.normalizePoint(e);
	  }

	  /**
	   * Called upon touchstart event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  touchStart(e){
	    this.touchstart(e);
	  }

	  /**
	   * Called upon touchstart event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  touchstart(e){
	    // Ensure touch has been released
	    this.touchAction.release(null);
	    console.log(e.touches, e);
	    //TouchList doesn't implement .map()
	    const currentPoints = [];
	    for (let i = 0; i < e.touches.length; i++) {
	      currentPoints.push(this.normalizePoint(e.touches[i]));
	    }
	    this.touchAction.insideCanvas = currentPoints.some(this.insideCanvas);
	    this.touchAction.press(currentPoints);
	    if(this.emulateMouse){
	      this.mousedown(e.touches[0]);
	    }
	  }

	  /**
	   * Called upon touchend event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  touchEnd(e){
	    this.touchend(e);
	  }

	  /**
	   * Called upon touchend event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  touchend(e){
	    //TouchList doesn't implement .map()
	    const currentPoints = [];
	    for (let i = 0; i < e.touches.length; i++) {
	      currentPoints.push(this.normalizePoint(e.touches[i]));
	    }
	    this.touchAction.release(currentPoints);
	    if(this.emulateMouse){
	      this.mouseUp(e.touches[0]);
	    }
	  }

	  /**
	   * Called upon touchmove event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  touchMove(e){
	    this.touchmove(e);
	  }

	  /**
	   * Called upon touchmove event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  touchmove(e){
	    //TouchList doesn't implement .map()
	    const currentPoints = [];
	    for (let i = 0; i < e.touches.length; i++) {
	      currentPoints.push(this.normalizePoint(e.touches[i]));
	    }
	    this.touchAction.positions = currentPoints;
	    if(this.touchAction.startPositions){
	      e.preventDefault();
	    }
	    if(this.emulateMouse){
	      this.mousemove(e.touches[0]);
	    }
	  }

	  /**
	   * Retrieves the GameAction associated with the keyCode on the event object
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @return {GameAction|null} The GameAction associated with the keyCode else null
	   */
	  getKeyAction(e) {
	    if (this.keyActions) {
	      return this.keyActions[e.keyCode] || this.keyActions[String.fromCharCode(e.keyCode)];
	    } else {
	      return null;
	    }
	  }

	  /**
	   * Called upon keypress event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use keydown instead - same syntax as normal event handling
	   */
	  keyPressed(e) {
	    this.keydown(e);
	  }

	  /**
	   * Called upon keydown event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use the lowercase name instead - same syntax as normal event handling
	   */
	  keyDown(e){
	    this.keydown(e);
	  }

	  /**
	   * Called upon keydown event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  keydown(e) {
	    var gameAction = this.getKeyAction(e);
	    if (gameAction && !gameAction.isPressed()) {
	      gameAction.press();
	    }
	  }

	  /**
	   * Called upon keyup event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   * @deprecated Use keyup instead - same syntax as normal event handling
	   */
	  keyReleased(e){
	    this.keyup(e);
	  }

	  /**
	   * Called upon keyup event
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} e Event object
	   */
	  keyup(e) {
	    var gameAction = this.getKeyAction(e);
	    if (gameAction) {
	      gameAction.release();
	    }
	  }

	  /**
	   * Used to get a normalized point out of an Event object
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} evt Event object
	   * @return {Point} Normalized point
	   * @deprecated Deprecated in favor of normalizePoint function (Same functionality, different name)
	   */
	  getMouseLoc(evt){
	    return this.normalizePoint(evt);
	  }

	  /**
	   * Used to get a normalized point out of an Event object
	   * @function
	   * @memberOf InputManager#
	   * @param  {Event} evt Event object
	   * @return {Point} Normalized point
	   */
	  normalizePoint(evt){
	    if(evt){
	      var coordsM = position(this.canvas);
	      if(this.zoomRatio){
	        return {
	          x: Math.round((evt.clientX - coordsM.x) / this.zoomRatio),
	          y: Math.round((evt.clientY - coordsM.y) / this.zoomRatio)
	        };
	      }else{
	        return {
	          x: Math.round(evt.clientX - coordsM.x),
	          y: Math.round(evt.clientY - coordsM.y)
	        };
	      }
	    }
	  }

	  /**
	   * Used to resize the canvas
	   * @function
	   * @memberOf InputManager#
	   */
	  resize(){
	    if(this.gameArea && this.canvasPercentage && this.canvas){
	      var canvasWidth = this.canvas.width;
	      var canvasHeight = this.canvas.height;

	      var bodyMargins = getMarginExtents(document.body);

	      var newWidth = window.innerWidth - bodyMargins.w;
	      var newHeight = window.innerHeight - bodyMargins.h;

	      var widthToHeight = canvasWidth / canvasHeight;
	      var newWidthToHeight = newWidth / newHeight;

	      var newWidthStyle = '';
	      var newHeightStyle = '';
	      if (newWidthToHeight > widthToHeight) {
	        newWidth = newHeight * widthToHeight;
	        newWidthStyle = newWidth + 'px';
	        newHeightStyle = newHeight + 'px';
	      } else {
	        newWidthStyle = newWidth + 'px';
	        newHeightStyle = Math.round(newWidth / widthToHeight) + 'px';
	      }

	      this.zoomRatio = newWidth / canvasWidth * this.canvasPercentage;

	      this.gameArea.style.width = newWidthStyle;
	      this.gameArea.style.height = newHeightStyle;

	      var canvasPercentageStyle = Math.floor(this.canvasPercentage * 100) + '%';
	      this.canvas.style.width = canvasPercentageStyle;
	      this.canvas.style.height = canvasPercentageStyle;
	      this.canvas.style.display = 'block';
	      this.canvas.style.marginLeft = 'auto';
	      this.canvas.style.marginRight = 'auto';
	    }
	  }

	  pushCleanup(a, b){
	    // console.log('pushCleanup', a, b);
	  }

	}

	module.exports = InputManager;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }

	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        assign(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */

	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;

	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);

	    this.primaryTouch = null;
	    this.lastTouches = [];
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }

	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}

	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];

	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}

	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture

	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;

	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }

	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});

	    this.id = uniqueId();

	    this.manager = null;

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(event) {
	            self.manager.emit(event, input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }

	        emit(self.options.event); // simple 'eventName' events

	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {

	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);

	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});

	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        recognizer = this.get(recognizer);

	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);

	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }

	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	        if (handler === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;

	if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/**
	 * The GameAction handles DOM events for use in games.
	 * @name GameAction
	 * @constructor GameAction
	 */

	/**
	 * A map of static constants for internal use
	 * @type {Object}
	 * @memberOf GameAction#
	 * @property {Number} NORMAL Normal behavior. The isPressed() method returns true as long as the key is held down.
	 * @property {Number} DETECT_INITAL_PRESS_ONLY Initial press behavior. The isPressed() method returns true only after the key is first pressed, and not again until the key is released and pressed again.
	 * @property {Number} STATE_RELEASED Value for released state
	 * @property {Number} STATE_PRESSED Value for pressed state
	 * @property {Number} STATE_WAITING_FOR_RELEASE Value for waiting for release state
	 * @property {Number} STATE_MOVED Value for moved state
	 */
	const statics = {
	  NORMAL: 0,
	  DETECT_INITAL_PRESS_ONLY: 1,
	  STATE_RELEASED: 0,
	  STATE_PRESSED: 1,
	  STATE_WAITING_FOR_RELEASE: 2,
	  STATE_MOVED: 3
	};

	class GameAction {
	  constructor(options = {}){
	    /**
	     * A name to reference the GameAction with
	     * @type {String}
	     * @memberOf GameAction#
	     * @default
	     */
	    this.name = null;

	    /**
	     * Whether or not to detect only the intial press of the game action
	     * @type {Number}
	     * @memberOf GameAction#
	     * @default
	     */
	    this.behavior = 0;

	    /**
	     * How many times the GameAction has been pressed
	     * @type {Number}
	     * @memberOf GameAction#
	     * @default
	     */
	    this.amount = 0;

	    /**
	     * The current state of the GameAction
	     * @type {Number}
	     * @memberOf GameAction#
	     * @default
	     */
	    this.state = 0;

	    this.statics = statics;

	    Object.assign(this, options);

	    this.reset();
	  }

	  /**
	   * Resets this GameAction so that it appears like it hasn't been pressed.
	   * @function
	   * @memberOf GameAction#
	   */
	  reset() {
	    this.state = statics.STATE_RELEASED;
	    this.amount = 0;
	  }

	  /**
	   * Taps this GameAction. Same as calling press() followed by release().
	   * @function
	   * @memberOf GameAction#
	   */
	  tap() {
	    this.press();
	    this.release();
	  }

	  /**
	   * Signals that the key was pressed.
	   * @function
	   * @memberOf GameAction#
	   */
	  press() {
	    this.state = statics.STATE_PRESSED;
	    if(this.behavior === statics.DETECT_INITAL_PRESS_ONLY){
	      this.pressAmt(1);
	    }
	  }

	  /**
	   * Signals that the key was pressed a specified number of times, or that the mouse move a specified distance.
	   * @function
	   * @memberOf GameAction#
	   * @param {Number} amount the number of times the key is pressed
	   */
	  pressAmt(amount) {
	    if (this.state !== statics.STATE_WAITING_FOR_RELEASE) {
	      this.amount += amount;
	      this.state = statics.STATE_WAITING_FOR_RELEASE;
	    }
	  }

	  /**
	   * Signals that the key was released
	   * @function
	   * @memberOf GameAction#
	   */
	  release() {
	    this.state = statics.STATE_RELEASED;
	  }

	  /**
	   * Returns whether the key was pressed or not since last checked.
	   * @function
	   * @memberOf GameAction#
	   * @return {Boolean} True if the key is pressed, else false
	   */
	  isPressed() {
	    if(this.state === statics.STATE_PRESSED){
	      return true;
	    } else {
	      return false;
	    }
	  }

	  /**
	   * For keys, this is the number of times the key was pressed since it was last checked.
	   * For mouse movement, this is the distance moved.
	   *
	   * This Resets the amount to zero after being checked!
	   *
	   * @function
	   * @memberOf GameAction#
	   * @return {Number} Number of times the key was pressed or distance mouse was moved
	   */
	  getAmount() {
	    var retVal = this.amount;
	    if (retVal !== 0) {
	      if (this.state === statics.STATE_RELEASED) {
	        this.amount = 0;
	      } else if (this.behavior === statics.DETECT_INITAL_PRESS_ONLY) {
	        this.state = statics.STATE_WAITING_FOR_RELEASE;
	        this.amount = 0;
	      }
	    }
	    return retVal;
	  }
	}

	module.exports = GameAction;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * A GameAction that handles Touch events
	 * @name TouchAction
	 * @constructor TouchAction
	 * @extends {GameAction}
	 */

	const GameAction = __webpack_require__(4);

	class TouchAction extends GameAction {
	  constructor(options = {}){
	    super(options);

	    /**
	     * Array of positions where touchstart happened
	     * @type {Array}
	     * @memberOf TouchAction#
	     * @default
	     */
	    this.startPositions = null;

	    /**
	     * Array of positions where touchend happened
	     * @type {Array}
	     * @memberOf TouchAction#
	     * @default
	     */
	    this.endPositions = null;

	    /**
	     * Array of positions where touchmove happened
	     * @type {Array}
	     * @memberOf TouchAction#
	     * @default
	     */
	    this.positions = null;

	    /**
	     * Wether any of the touch actions originated inside the canvas
	     * @type {Boolean}
	     * @memberOf TouchAction#
	     * @default
	     */
	    this.insideCanvas = null;

	    Object.assign(this, options);

	  }

	  /**
	   * Signals that the touch was initiated.
	   * @function
	   * @memberOf TouchAction#
	   * @param {Array} startPositions Array of points where touch was pressed
	   */
	  press(startPositions){
	    this.startPositions = startPositions;
	    this.positions = startPositions;
	    super.press(startPositions);
	  }

	  /**
	   * Signals that the touch was released
	   * @function
	   * @memberOf TouchAction#
	   * @param {Array} endPositions Array of points where touch was released
	   */
	  release(endPositions){
	    this.endPositions = endPositions;
	    super.release(endPositions);
	  }
	}

	module.exports = TouchAction;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * A GameAction that handles Mouse events
	 * @name MouseAction
	 * @constructor MouseAction
	 * @extends {GameAction}
	 */

	const GameAction = __webpack_require__(4);

	class MouseAction extends GameAction {
	  constructor(options = {}){
	    super(options);

	    /**
	     * Position where mousedown happened
	     * @type {Point}
	     * @memberOf MouseAction#
	     * @default
	     */
	    this.startPosition = null;

	    /**
	     * Position where mouseup happened
	     * @type {Point}
	     * @memberOf MouseAction#
	     * @default
	     */
	    this.endPosition = null;

	    /**
	     * Position where mousemove happened
	     * @type {Point}
	     * @memberOf MouseAction#
	     * @default
	     */
	    this.position = null;

	    /**
	     * Wether the mouse action originated inside the canvas
	     * @type {Boolean}
	     * @memberOf MouseAction#
	     * @default
	     */
	    this.insideCanvas = null;

	    Object.assign(this, options);

	  }

	  /**
	   * Signals that the mouse was pressed.
	   * @function
	   * @memberOf GameAction#
	   */
	  press(startPosition){
	    this.startPosition = startPosition;
	    this.position = startPosition;
	    super.press(startPosition);
	  }

	  /**
	   * Signals that the mouse was released
	   * @function
	   * @memberOf MouseAction#
	   * @param  {Point} endPosition The point where mouse was released
	   */
	  release(endPosition){
	    this.endPosition = endPosition || this.position;
	    super.release(endPosition);
	  }
	}

	module.exports = MouseAction;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	function insideCanvas(pt, canvas){
	  if((pt.x < 0) || (pt.x >  canvas.width) || (pt.y < 0) || (pt.y > canvas.height)){
	    return false;
	  } else {
	    return true;
	  }
	}

	module.exports = insideCanvas;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = {
	  CANCEL: 3,
	  HELP: 6,
	  BACK_SPACE: 8,
	  TAB: 9,
	  CLEAR: 12,
	  RETURN: 13,
	  ENTER: 14,
	  SHIFT: 16,
	  CONTROL: 17,
	  ALT: 18,
	  PAUSE: 19,
	  CAPS_LOCK: 20,
	  ESCAPE: 27,
	  SPACE: 32,
	  PAGE_UP: 33,
	  PAGE_DOWN: 34,
	  END: 35,
	  HOME: 36,
	  LEFT: 37,
	  UP: 38,
	  RIGHT: 39,
	  DOWN: 40,
	  PRINTSCREEN: 44,
	  INSERT: 45,
	  DELETE: 46,
	  NUM0: 48,
	  NUM1: 49,
	  NUM2: 50,
	  NUM3: 51,
	  NUM4: 52,
	  NUM5: 53,
	  NUM6: 54,
	  NUM7: 55,
	  NUM8: 56,
	  NUM9: 57,
	  SEMICOLON: 59,
	  EQUALS: 61,
	  A: 65,
	  B: 66,
	  C: 67,
	  D: 68,
	  E: 69,
	  F: 70,
	  G: 71,
	  H: 72,
	  I: 73,
	  J: 74,
	  K: 75,
	  L: 76,
	  M: 77,
	  N: 78,
	  O: 79,
	  P: 80,
	  Q: 81,
	  R: 82,
	  S: 83,
	  T: 84,
	  U: 85,
	  V: 86,
	  W: 87,
	  X: 88,
	  Y: 89,
	  Z: 90,
	  CONTEXT_MENU: 93,
	  NUMPAD0: 96,
	  NUMPAD1: 97,
	  NUMPAD2: 98,
	  NUMPAD3: 99,
	  NUMPAD4: 100,
	  NUMPAD5: 101,
	  NUMPAD6: 102,
	  NUMPAD7: 103,
	  NUMPAD8: 104,
	  NUMPAD9: 105,
	  MULTIPLY: 106,
	  ADD: 107,
	  SEPARATOR: 108,
	  SUBTRACT: 109,
	  DECIMAL: 110,
	  DIVIDE: 111,
	  F1: 112,
	  F2: 113,
	  F3: 114,
	  F4: 115,
	  F5: 116,
	  F6: 117,
	  F7: 118,
	  F8: 119,
	  F9: 120,
	  F10: 121,
	  F11: 122,
	  F12: 123,
	  F13: 124,
	  F14: 125,
	  F15: 126,
	  F16: 127,
	  F17: 128,
	  F18: 129,
	  F19: 130,
	  F20: 131,
	  F21: 132,
	  F22: 133,
	  F23: 134,
	  F24: 135,
	  NUM_LOCK: 144,
	  SCROLL_LOCK: 145,
	  UP_DPAD: 175,
	  DOWN_DPAD: 176,
	  LEFT_DPAD: 177,
	  RIGHT_DPAD: 178,
	  COMMA: 188,
	  PERIOD: 190,
	  SLASH: 191,
	  BACK_QUOTE: 192,
	  OPEN_BRACKET: 219,
	  BACK_SLASH: 220,
	  CLOSE_BRACKET: 221,
	  QUOTE: 222,
	  META: 224
	};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * The ResourceManager handles loading images and sounds for use in games.
	 * @name ResourceManager
	 * @constructor ResourceManager
	 */

	 'use strict';

	const has = __webpack_require__(10);
	const Sound = __webpack_require__(12);
	const WebAudio = __webpack_require__(13);

	var resourceList = {};

	//TODO: move these to its own module for unit testing?
	function normalizePath(baseDir, path){
	  var joinedPath = path;
	  if(baseDir){
	    joinedPath = [baseDir, path].join('/');
	  }
	  return joinedPath.replace(/\/{2,}/g, '/');
	}

	function flipX(image){
	  var offscreenCanvas = document.createElement('canvas');
	  offscreenCanvas.height = image.height;
	  offscreenCanvas.width = image.width;
	  var ctx = offscreenCanvas.getContext('2d');

	  ctx.translate(offscreenCanvas.width, 0);
	  ctx.scale(-1, 1);
	  ctx.drawImage(image, 0, 0);
	  return offscreenCanvas.toDataURL();
	}

	function flipY(image){
	  var offscreenCanvas = document.createElement('canvas');
	  offscreenCanvas.height = image.height;
	  offscreenCanvas.width = image.width;
	  var ctx = offscreenCanvas.getContext('2d');

	  ctx.translate(0, offscreenCanvas.height);
	  ctx.scale(1, -1);
	  ctx.drawImage(image, 0, 0);
	  return offscreenCanvas.toDataURL();
	}

	class ImageWrapper {
	  constructor(filename){
	    var self = this;
	    self.name = filename;
	    self.complete = false;
	    self.img = new Image();
	    self.img.addEventListener('load', function() {
	      self.complete = true;
	    }, false);
	  }

	  load(){
	    this.img.src = this.name;
	  }
	}


	class ResourceManager {

	  constructor(options = {}){

	    /**
	     * Whether all the resources have been loaded
	     * @type {Boolean}
	     * @memberOf ResourceManager#
	     * @default
	     */
	    this.allLoaded = false;

	    /**
	     * The base directory to load images from
	     * @type {String}
	     * @memberOf ResourceManager#
	     * @default
	     */
	    this.imageDir = null;

	    /**
	     * The base directory to load sounds from
	     * @type {String}
	     * @memberOf ResourceManager#
	     * @default
	     */
	    this.soundDir = null;

	    /**
	     * A map of all the resources by their URLs
	     * @type {Object}
	     * @memberOf ResourceManager#
	     * @default
	     */
	    this.resourceList = resourceList;

	    Object.assign(this, options);

	    // TODO not sure a better way
	    if(!this.Sound){
	      if(has('WebAudio')){
	        this.Sound = WebAudio;
	      }
	      else{
	        this.Sound = Sound;
	      }
	    }
	  }

	  /**
	   * Loads an image (or a collection of images), and tracks if it has finished loading
	   * @function
	   * @memberOf ResourceManager#
	   * @param {String|Array} files Filename of the image relative the Game's HTML page.
	   * @returns {Image|Array} Return type based on argument: Image if String or Array of Images if Array
	   */
	  loadImage(files){
	    let singleFile = false;
	    if(!Array.isArray(files)) {
	      singleFile = true;
	      files = [files];
	    }

	    const fileList = files.map((file) => {
	      const filename = normalizePath(this.imageDir, file);
	      //if we already have the image, just return it
	      if(this.resourceList[filename]){
	        return this.resourceList[filename].img;
	      }
	      this.allLoaded = false;

	      const wrapper = new ImageWrapper(filename);
	      // Need to explicitly call load because flipImage also uses this object
	      // which is probably a bad idea and should change in future
	      // TODO: different objects for flipped image and regular image
	      wrapper.load();
	      this.resourceList[filename] = wrapper;
	      return wrapper.img;
	    });

	    return singleFile ? fileList[0] : fileList;
	  }

	  /**
	   * Loads a sound file (or a collection of sound files), and tracks if it has finished loading
	   * @function
	   * @memberOf ResourceManager#
	   * @param {String|Array} filename Filename of the sound relative the Game's HTML page.
	   * @returns {Sound|Array} Return type based on argument: Sound Object if String or Array of Sound Objects if Array
	   */
	  loadSound(files){
	    let singleFile = false;
	    if(!Array.isArray(files)) {
	      singleFile = true;
	      files = [files];
	    }

	    const fileList = files.map((file) => {
	      const filename = normalizePath(this.soundDir, file);
	      //if we already have the sound, just return it
	      if(this.resourceList[filename]){
	        return this.resourceList[filename];
	      }
	      this.allLoaded = false;

	      const sound = new this.Sound(filename);
	      this.resourceList[filename] = sound;
	      return sound;
	    });

	    return singleFile ? fileList[0] : fileList;
	  }

	  /**
	   * Flips an image using the logic in a flip function passed and attaches to resource manager with name
	   * @function
	   * @memberOf ResourceManager#
	   * @param  {String|Number} name Name for caching flipped image
	   * @param  {Image} image Image to be flipped
	   * @param  {Function} flipFn Function containing logic to flip image
	   * @return {Image} Flipped image
	   */
	  flipImage(name, image, flipFn){
	    this.allLoaded = false;

	    const wrapper = new ImageWrapper(name);
	    this.resourceList[name] = wrapper;
	    const img2 = new Image();
	    function doFlip() {
	      wrapper.img.src = flipFn(img2);
	      img2.removeEventListener('load', doFlip);
	    }
	    img2.addEventListener('load', doFlip);
	    img2.src = image.src;

	    return wrapper.img;
	  }

	  /**
	   * Flip image along x-axis using default flip logic
	   * @function
	   * @memberOf ResourceManager#
	   * @param  {String|Number} name Name for caching flipped image
	   * @param  {Image} image Image to be flipped
	   * @return {Image} Flipped image
	   */
	  flipImageX(name, image){
	    return this.flipImage(name, image, flipX);
	  }

	  /**
	   * Flip image along the y-axis using default flip logic
	   * @function
	   * @memberOf ResourceManager#
	   * @param  {String|Number} name Name for caching flipped image
	   * @param  {Image} image Image to be flipped
	   * @return {Image} Flipped image
	   */
	  flipImageY(name, image){
	    return this.flipImage(name, image, flipY);
	  }

	  /**
	   * Checks whether the resources have finished loading
	   * @function
	   * @memberOf ResourceManager#
	   */
	  resourcesReady(){
	    if(this.allLoaded){
	      return true;
	    } else {
	      for(var filename in this.resourceList){
	        var resource = this.resourceList[filename];
	        if(!resource.complete){
	          return false;
	        }
	      }
	      this.allLoaded = true;
	      return true;
	    }
	  }

	  /**
	   * Gets the percent of resources loaded.
	   * @function
	   * @memberOf ResourceManager#
	   * @return {Number} The percent of resources loaded
	   */
	  getPercentComplete(){
	    var numComplete = 0.0;
	    var length = 0;
	    for(var filename in this.resourceList){
	      var resource = this.resourceList[filename];
	      length++;
	      if(resource.complete){
	        numComplete = numComplete + 1.0;
	      }
	    }
	    if(length === 0){
	      return 0;
	    } else {
	      return Math.round((numComplete / length) * 100.0);
	    }
	  }

	}

	module.exports = ResourceManager;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// hacky simple implementation of has

	const globalAudioContext = __webpack_require__(11);


	function has(check){

	  if(check == 'shittySound'){
	    return !!((has('android') || has('ios')) && has('webkit'));
	  }
	  else if(check == 'android'){
	    return (parseFloat(navigator.userAgent.split("Android ")[1]) || undefined);
	  }
	  else if(check == 'ios'){
	    //TODO need something for this
	    return false;
	  }
	  else if(check == 'webkit'){
	    return (parseFloat(navigator.userAgent.split("WebKit/")[1]) || undefined);
	  }
	  else if(check == 'WebAudio'){
	    return !!global.AudioContext;
	  }
	  else if (check === 'touch') {
	    return 'ontouchstart' in document.documentElement;
	  }

	  return false;
	}

	module.exports = has;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	'use strict';

	var vendors = ['ms', 'moz', 'webkit', 'o'];

	for(var x = 0; x < vendors.length && !window.AudioContext; ++x) {
	  window.AudioContext = window[vendors[x]+'AudioContext'];
	}

	module.exports = window.AudioContext;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

	/**
	 * An Audio object that implements a generic API
	 * @name Sound
	 * @constructor Sound
	 */


	/**
	 * Map of audio types and codecs used in fallback loading of sounds <br>
	 * Reference: https://developer.mozilla.org/en-US/docs/HTML/Supported_media_formats
	 * @type {Object}
	 * @memberOf Sound#
	 * @property {String} 'audio/mpeg' '.mp3'
	 * @property {String} 'audio/webm' '.webm'
	 * @property {String} 'audio/ogg' '.ogg'
	 * @property {String} 'audio/wav' '.wav'
	 * @property {String} 'audio/aac' '.aac'
	 * @property {String} 'audio/x-m4a' '.m4a'
	 * @example
	 * // To override the default formats:
	 * // Do this before loading any sounds
	 * require([
	 *   'frozen/sounds/Sound'
	 * ], function(Sound){
	 *   Sound.prototype.formats = {
	 *     'audio/mpeg': '.mp3',
	 *     'audio/webm': '.webm'
	 *   };
	 * });
	 */
	const formats = {
	  'audio/mpeg': '.mp3',
	  'audio/webm': '.webm',
	  'audio/ogg': '.ogg',
	  'audio/wav': '.wav',
	  'audio/aac': '.aac',
	  'audio/x-m4a': '.m4a'
	};



	class Sound {
	  constructor(options = {}){

	    /**
	     * The name of the Audio object - typically the filename
	     * @type {String}
	     * @memberOf Sound#
	     * @default
	     */
	    this.name = null;

	    /**
	     * Signals if the Audio object has completed loading
	     * @type {Boolean}
	     * @memberOf Sound#
	     * @default
	     */
	    this.complete = false;

	    /**
	     * An array of extensions the browser "probably" can play
	     * @type {Array}
	     * @memberOf Sound#
	     * @default
	     */
	    this.probably = [];

	    /**
	     * An array of extensions the browser "maybe" can play
	     * @type {Array}
	     * @memberOf Sound#
	     * @default
	     */
	    this.maybe = [];

	    Object.assign(this, options);

	    this.formats = formats;

	    if(typeof options === 'string'){
	      this.load(options);
	    }
	  }

	  /**
	   * Load the sound by filename
	   * @function
	   * @memberOf Sound#
	   * @param  {String} filename The filename of the file to load
	   */
	  load(filename){
	    this.name = filename;
	    this.complete = true;
	  }

	  /**
	   * Loop the sound at a certain volume
	   * @function
	   * @memberOf Sound#
	   * @param  {Number} volume Value of volume - between 0 and 1
	   */
	  loop(volume){}

	  /**
	   * Play the sound at a certain volume and start time
	   * @function
	   * @memberOf Sound#
	   * @param  {Number} volume    Value of volume - between 0 and 1
	   * @param  {Number} startTime Value of milliseconds into the track to start
	   */
	  play(volume, startTime){}

	  /**
	   * Method used to construct Audio objects internally
	   * @function
	   * @memberOf Sound#
	   * @private
	   * @param  {Number} volume Value of volume - between 0 and 1
	   * @param  {Boolean} loop Whether or not to loop audio
	   * @return {Audio} Audio object that was constructed
	   */
	  _initAudio(volume, loop){}

	  /**
	   * Method used to generate a cache of extensions (probably/maybe arrays) to try loading
	   * @function
	   * @memberOf Sound#
	   * @private
	   * @return {String} First extension to try loading
	   */
	  _chooseFormat(){
	    if(!this.probably.length && !this.maybe.length){
	      // Figure out the best extension if we have no cache
	      var audio = new Audio();
	      var codec;
	      var result;
	      for(codec in this.formats){
	        result = audio.canPlayType(codec);
	        if(result === 'probably'){
	          this.probably.push(this.formats[codec]);
	          continue;
	        }

	        if(result === 'maybe'){
	          this.maybe.push(this.formats[codec]);
	          continue;
	        }
	      }
	    }

	    if(this.probably.length){
	      return this.probably[0];
	    }

	    if(this.maybe.length){
	      return this.maybe[0];
	    }

	    return '';
	  }

	  /**
	   * Method used to remove a extension that didn't work and return the next viable extension
	   * @function
	   * @memberOf Sound#
	   * @private
	   * @return {String} Next extension to try loading
	   */
	  _nextFormat(){
	    if(this.probably.length > 1){
	      this.probably.shift();
	      return this.probably[0];
	    }

	    if(this.probably.length === 1){
	      this.probably.length = 0;
	      if(this.maybe.length){
	        return this.maybe[0];
	      }
	    }

	    if(this.maybe.length > 1){
	      this.maybe.shift();
	      return this.maybe[0];
	    }

	    if(this.maybe.length === 1){
	      this.maybe.length = 0;
	    }

	    return '';
	  }

	}

	module.exports = Sound;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * An Audio object that implements WebAudio into a generic API
	 * @name WebAudio
	 * @constructor WebAudio
	 * @extends Sound
	 */

	const Sound = __webpack_require__(12);
	const removeExtension = __webpack_require__(14);
	const has = __webpack_require__(10);

	var audioContext = null;


	if(has('WebAudio')){
	  audioContext = new window.AudioContext();
	}

	if(has('shittySound')){
	  // Similar strategy to https://github.com/CreateJS/SoundJS
	  function handleShitty() {
	    const source = audioContext.createBufferSource();
	    source.buffer = audioContext.createBuffer(1, 1, 22050);
	    source.connect(audioContext.destination);
	    source.start(0);
	    document.removeEventListener('touchstart', handleShitty);
	  }
	  document.addEventListener('touchstart', handleShitty);
	}

	class WebAudio extends Sound {
	  constructor(options = {}){
	    super(options);

	    /**
	     * The WebAudio AudioContext - used to perform operations on a sound
	     * @type {AudioContext}
	     * @memberOf WebAudio#
	     * @default
	     */
	    this.audioContext = audioContext;

	    /**
	     * The sound buffer
	     * @type {Buffer}
	     * @memberOf WebAudio#
	     * @default
	     */
	    this.buffer = null;

	    Object.assign(this, options);
	  }

	  load(filename){
	    var self = this;

	    this.name = filename;

	    var basename = removeExtension(filename);
	    if(basename === filename){
	      filename = basename + this._chooseFormat();
	    }
	    // filename = req.toUrl(filename);

	    function decodeAudioData(e){
	      // Decode asynchronously
	      self.audioContext.decodeAudioData(e.target.response,
	        function(buffer){
	          self.buffer = buffer;
	          self.complete = true;
	        },
	        function(err){
	          var format = self._nextFormat();
	          if(format){
	            self.load(self.name);
	          } else {
	            self.complete = true;
	          }
	        }
	      );
	    }

	    // If the browser has AudioContext, it's new enough for XMLHttpRequest
	    var request = new XMLHttpRequest();
	    request.open('GET', filename, true);
	    request.responseType = 'arraybuffer';

	    request.onload = decodeAudioData;
	    request.send();
	  }

	  loop(volume){
	    // Return early if we don't have a buffer to protect from unloaded resources
	    if(!this.buffer){
	      return;
	    }

	    var audio = this._initAudio(volume, true);
	    audio.start(0);
	  }

	  play(volume, startTime){
	    // Return early if we don't have a buffer to protect from unloaded resources
	    if(!this.buffer){
	      return;
	    }

	    startTime = startTime || 0;

	    var audio = this._initAudio(volume, false);
	    audio.start(startTime);
	  }

	  _initAudio(volume, loop){
	    loop = typeof loop === 'boolean' ? loop : false;

	    var source = this.audioContext.createBufferSource();
	    source.buffer = this.buffer;
	    source.loop = loop;
	    if(volume){
	      var gainNode = this.audioContext.createGain();
	      gainNode.gain.value = volume;
	      source.connect(gainNode);
	      gainNode.connect(this.audioContext.destination);
	    } else {
	      source.connect(this.audioContext.destination);
	    }
	    return source;
	  }
	}

	module.exports = WebAudio;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	'use strict';

	function removeExtension(path){
	  // only strips off extensions that have length of 4 or less
	  // regex from http://stackoverflow.com/questions/1818310/regular-expression-to-remove-a-files-extension
	  return path.replace(/(.*)\.[^.]{1,4}$/, '');
	}

	module.exports = removeExtension;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Represents a series of frames that can be rendered as an animation.
	 * @name Animation
	 * @constructor Animation
	 */

	const AnimFrame = __webpack_require__(16);


	class Animation {
	  constructor(options = {}){

	    /**
	     * The index of the current frame being used to render this Animation
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.currFrameIndex = 0;

	    /**
	     * The current number of milliseconds that this animation has been running
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.animTime = 0;

	    /**
	     * The total number of milliseconds for a complete cycle
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.totalDuration = 0;

	    /**
	     * The height in pixels
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.height = 64;

	    /**
	     * The width in pixels
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.width = 64;

	    /**
	     * The image to render
	     * @type {Image}
	     * @memberOf Animation#
	     * @default
	     */
	    this.image = null;

	    /**
	     * The offset of the of pixels in the x slot from the source image
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.offsetX = 0;

	    /**
	     * The offset of the of pixels in the y slot from the source image
	     * @type {Number}
	     * @memberOf Animation#
	     * @default
	     */
	    this.offsetY = 0;

	    this.frames = undefined;


	    Object.assign(this, options);

	    this.start();
	  }

	  /**
	   * Used to create an animation from a sheet of tiles
	   * @function
	   * @memberOf Animation#
	   * @param  {Number} frameCount Number of frames in the animation
	   * @param  {Number|Array} frameTimes Value or array of values corresponding to amount of time per frame
	   * @param  {Image} img Image sheet to create animation from
	   * @param  {Number} w Width of each tile in pixels
	   * @param  {Number} h Height of each tile in pixels
	   * @param  {Number} ySlot Slot on Y axis to start creating tiles
	   * @return {Animation} Animation generated using parameters
	   */
	  createFromSheet(frameCount, frameTimes, img, w, h, ySlot){
	    var anim = new Animation({
	      image: img,
	      height: h,
	      width: w
	    });

	    var isFTArray = Array.isArray(frameTimes);

	    var currentFrameTime = 1;
	    if(!ySlot){
	      ySlot = 0;
	    }
	    for(var j = 0; j < frameCount; j++){
	      if(isFTArray){
	        currentFrameTime = frameTimes[j];
	      } else {
	        currentFrameTime = frameTimes;
	      }
	      anim.addFrame(currentFrameTime, j, ySlot);
	    }
	    return anim;
	  }

	  /**
	   * Creates a duplicate of this animation. The list of frames
	   * are shared between the two Animations, but each Animation
	   * can be animated independently.
	   * @function
	   * @memberOf Animation#
	   */
	  clone(){
	    return new Animation({
	      image: this.image,
	      frames: this.frames,
	      totalDuration: this.totalDuration
	    });
	  }

	  /**
	   * Adds an image to the animation with the specified duration (time to display the image).
	   * @function
	   * @memberOf Animation#
	   * @param {Number} duration Duration of the frame
	   * @param {Number} imageSlotX Slot on the X axis for the frame
	   * @param {Number} imageSlotY Slot on the Y axis for the frame
	   */
	  addFrame(duration, imageSlotX, imageSlotY){
	    if(!this.frames){
	      this.frames = [];
	    }
	    this.totalDuration += duration;
	    this.frames.push(new AnimFrame({
	      endTime: this.totalDuration,
	      image: this.image,
	      imgSlotX: imageSlotX,
	      imgSlotY: imageSlotY
	    }));
	  }

	  /**
	   * Starts this animation over from the beginning.
	   * @function
	   * @memberOf Animation#
	   */
	  start(){
	    this.animTime = 0;
	    this.currFrameIndex = 0;
	  }

	  /**
	   * Updates this animation's current image (frame), if neccesary.
	   * @function
	   * @memberOf Animation#
	   * @param {Number} elapsedTime Elapsed time in milliseconds
	   */
	  update(elapsedTime){
	    if (this.frames.length > 1) {
	      this.animTime += elapsedTime;

	      if (this.animTime >= this.totalDuration) {
	        this.animTime = this.animTime % this.totalDuration;
	        this.currFrameIndex = 0;
	      }

	      while (this.animTime > this.frames[this.currFrameIndex].endTime) {
	        this.currFrameIndex++;
	      }
	    }
	  }

	  /**
	   * Gets this Animation's current animation frame. Returns null if this animation has no frames.
	   * @function
	   * @memberOf Animation#
	   * @return {AnimationFrame|null} The animation frame at the current frame index or null if no frames are available
	   */
	  getCurrentFrame(){
	    if (this.frames.length === 0) {
	      return null;
	    } else {
	      return this.frames[this.currFrameIndex];
	    }
	  }

	  /**
	   * Draws the current frame into a 2d context.
	   * @function
	   * @memberOf Animation#
	   * @param {Context} context The HTML5 drawing canvas
	   * @param {Number} x The x coordinate in the graphics context
	   * @param {Number} y The y coordinate in the graphics context
	   */
	  draw(context, x, y){
	    var cf = this.getCurrentFrame();
	    context.drawImage(this.image, cf.imgSlotX * this.width + this.offsetX, cf.imgSlotY * this.height + this.offsetY, this.width, this.height, x, y, this.width, this.height);
	  }
	}

	module.exports = Animation;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

	/**
	 * Represents a a single frame in an animation.
	 * @name AnimationFrame
	 * @constructor AnimationFrame
	 * @param {Object} mixin Object containing properties to mixin
	 */

	class AnimFrame {
	  constructor(options = {}){

	    /**
	     * The ending time in milliseconds of this frame relative to its Animation
	     * @type {Number}
	     * @memberOf AnimationFrame#
	     * @default
	     */
	    this.endTime = 0;

	    /**
	     * The horizontal position of the group of frames contained in a single image
	     * @type {Number}
	     * @memberOf AnimationFrame#
	     * @default
	     */
	    this.imgSlotX = 0;

	    /**
	     * The vertical position of the group of frames contained in a single image
	     * @type {Number}
	     * @memberOf AnimationFrame#
	     * @default
	     */
	    this.imgSlotY = 0;

	    /**
	     * The image to render
	     * @type {Image}
	     * @memberOf AnimationFrame#
	     * @default
	     */
	    this.image = null;

	    Object.assign(this, options);
	  }

	}

	module.exports = AnimFrame;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	const averagePoints = __webpack_require__(18);
	const degreesToRadians = __webpack_require__(19);
	const radiansToDegrees = __webpack_require__(20);
	const pointInPolygon = __webpack_require__(21);
	const distance = __webpack_require__(22);
	const degreesFromCenter = __webpack_require__(23);
	const radiansFromCenter = __webpack_require__(24);
	const scalePoints = __webpack_require__(25);
	const translatePoints = __webpack_require__(26);
	const insideCanvas = __webpack_require__(7);


	/**
	 * Math utility libraries
	 * @exports utils
	 */
	const utils = {
	  /**
	   * Gets the average point value in an array of points.
	   * @function
	   * @param {Array} points
	   * @return {Object} An object with x and y values
	   */
	  averagePoints,

	  /**
	   * Convert degrees to raidans
	   * @function
	   * @param {Number} degrees
	   * @return {Number} A value in radians
	   */
	  degreesToRadians,

	  /**
	   * Convert radians to degrees
	   * @function
	   * @param {Number} radians
	   * @return {Number} A value in degrees
	   */
	  radiansToDegrees,

	  /**
	   * Checks if a point is in a polygon
	   * @function
	   * @param {Object} point Object with an x and y value
	   * @param {Array} polygon Array of points
	   * @return {Boolean} True if the point is inside the polygon
	   */
	  pointInPolygon,

	  /**
	   * Returns the distance between 2 points
	   * @function
	   * @param {Object} point1 Object with an x and y value
	   * @param {Object} point2 Object with an x and y value
	   * @return {Number} The distance
	   */
	  distance,

	  /**
	   * Degrees a point is offset from a center point
	   * @function
	   * @param {Object} center Object with an x and y value
	   * @param {Object} point Object with an x and y value
	   * @return {Number} A value in degrees
	   */
	  degreesFromCenter,

	  /**
	   * Radians a point is offset from a center point
	   * @function
	   * @param {Object} center Object with an x and y value
	   * @param {Object} point Object with an x and y value
	   * @return {Number} A value in radians
	   */
	  radiansFromCenter,

	  /**
	   * Scale a point or array of points.
	   * @function
	   * @param {Object|Array} points A point or array of points
	   * @param {Object} scale Object with an x and y value
	   * @return {Object|Array} A scaled point or array of points
	   */
	  scalePoints,

	  /**
	   * Translate a point or array of points
	   * @function
	   * @param {Object|Array} points A point or array of points
	   * @param {Object} offset Object with an x and y value
	   * @return {Object|Array} A translated point or array of points
	   */
	  translatePoints,

	  /**
	   * Check whether a point is inside a canvas
	   * @function
	   * @param {Object} point A point to test
	   * @param {Object} canvas Object with height and width properties
	   * @return {Boolean} True if inside canvas else false
	   */
	  insideCanvas
	};

	module.exports = utils;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	
	function averagePoints(points){
	  var retVal = {x: 0, y: 0};
	  points.forEach(points, function(point){
	    retVal.x+= point.x;
	    retVal.y+= point.y;
	  });
	  retVal.x = retVal.x / points.length;
	  retVal.y = retVal.y / points.length;
	  return retVal;
	}

	module.exports = averagePoints;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

	const radConst = Math.PI / 180.0;

	function degreesToRadians(degrees){
	  return degrees * radConst;
	}

	module.exports = degreesToRadians;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';

	const degConst = 180.0 / Math.PI;

	function radiansToDegrees(radians){
	  return radians * degConst;
	}

	module.exports = radiansToDegrees;


/***/ }),
/* 21 */
/***/ (function(module, exports) {

	'use strict';

	// Using Ray-Casting formula based on
	// http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
	// and https://github.com/substack/point-in-polygon/
	// Re-written for most readability and for use with point objects instead of arrays

	function pointInPoly(point, polygon){
	  if(!point || !polygon){
	    return false;
	  }

	  var poly = polygon.points || polygon;

	  var insidePoly = false;
	  var j = poly.length - 1;

	  for(var i = 0; i < poly.length; j = i++){
	    var xi = poly[i].x;
	    var yi = poly[i].y;
	    var xj = poly[j].x;
	    var yj = poly[j].y;

	    if(yi > point.y !== yj > point.y){
	      if(point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi){
	        insidePoly = !insidePoly;
	      }
	    }
	  }

	  return insidePoly;
	}

	module.exports = pointInPoly;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	function distance(p1, p2){
	  return Math.sqrt( ((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y)) );
	}

	module.exports = distance;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	const radiansToDegrees = __webpack_require__(20);
	const radiansFromCenter = __webpack_require__(24);

	function degreesFromCenter(center, pt){
	  return radiansToDegrees(radiansFromCenter(center, pt));
	}

	module.exports = degreesFromCenter;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	'use strict';

	const origin = {x: 0.0, y: 0.0};

	function radiansFromCenter(center, pt){

	  //if null or zero is passed in for center, we'll use the origin
	  center = center || origin;

	  //same point
	  if((center.x === pt.x) && (center.y === pt.y)){
	    return 0;
	  }else if(center.x === pt.x){
	    if(center.y > pt.y){
	      return 0;
	    }else{
	      return Math.PI;
	    }
	  }else if(center.y === pt.y){
	    if(center.x > pt.x){
	      return 1.5 * Math.PI;
	    }else{
	      return Math.PI / 2;
	    }
	  }else if((center.x < pt.x) && (center.y > pt.y)){
	    //quadrant 1
	    //console.log('quad1',center.x,center.y,pt.x,pt.y,'o',pt.x - center.x,'a',pt.y - center.y);
	    return Math.atan((pt.x - center.x)/(center.y - pt.y));
	  }
	  else if((center.x < pt.x) && (center.y < pt.y)){
	    //quadrant 2
	    //console.log('quad2',center.x,center.y,pt.x,pt.y);
	    return Math.PI / 2 + Math.atan((pt.y - center.y)/(pt.x - center.x));
	  }
	  else if((center.x > pt.x) && (center.y < pt.y)){
	    //quadrant 3
	    //console.log('quad3',center.x,center.y,pt.x,pt.y);
	    return Math.PI + Math.atan((center.x - pt.x)/(pt.y - center.y));
	  }
	  else{
	    //quadrant 4
	    //console.log('quad4',center.x,center.y,pt.x,pt.y);
	    return 1.5 * Math.PI + Math.atan((center.y - pt.y)/(center.x - pt.x));
	  }

	}

	module.exports = radiansFromCenter;


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	
	function scalePoints(points, scale){
	  if(Array.isArray(points)){
	    points = points.map(function(point){
	      return scalePoints(point, scale);
	    });
	  } else if(typeof scale === 'object'){
	    points = {
	      x: points.x * scale.x,
	      y: points.y * scale.y
	    };
	  } else {
	    points = {
	      x: points.x * scale,
	      y: points.y * scale
	    };
	  }
	  return points;
	}

	module.exports = scalePoints;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	
	function translatePoints(points, translation){
	  if(Array.isArray(points)){
	    points = points.map(function(point){
	      return translatePoints(point, translation);
	    });
	  } else {
	    points = {
	      x: points.x,
	      y: points.y
	    };

	    if(translation.x != null){
	      points.x += translation.x;
	    }

	    if(translation.y != null){
	      points.y += translation.y;
	    }
	  }
	  return points;
	}

	module.exports = translatePoints;


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	/**
	 * The Sprite class represents a simple animated character for a game
	 * @name Sprite
	 * @constructor Sprite
	 */

	class Sprite {
	  constructor(options = {}){

	    /**
	     * The x position of the sprite in pixels
	     * @type {Number}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.x = 0.0;

	    /**
	     * The y position of the sprite in pixels
	     * @type {Number}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.y = 0.0;

	    /**
	     * The x component of the velocity in pixels per second
	     * @type {Number}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.dx = 0.0;

	    /**
	     * The y component of the velocity in pixels per second
	     * @type {Number}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.dy = 0.0;

	    /**
	     * The max speed a sprite can move in either direction
	     * @type {Number}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.maxSpeed = 0.0;

	    /**
	     * The name of this Sprite
	     * @type {String}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.name = null;

	    /**
	     * The radius of this sprite in pixels for simple collision detection
	     * @type {Number}
	     * @memberOf Sprite#
	     * @default
	     */
	    this.collisionRadius = 40;

	    Object.assign(this, options);
	  }

	  /**
	   * Updates this Sprite's Animation and its position based on the velocity.
	   * @function
	   * @memberOf Sprite#
	   * @param {Number} elapsedTime The elapsed time in milliseconds since the previous update
	   */
	  update(elapsedTime){
	    this.x += this.dx * elapsedTime;
	    this.y += this.dy * elapsedTime;
	    this.anim.update(elapsedTime);
	  }

	  /**
	   * Returns the maxSpeed up to the speed limit
	   * @function
	   * @memberOf Sprite#
	   * @param {Number} v Speed limit
	   * @return {Number} maxSpeed up to speed limit
	   */
	  limitSpeed(v){
	    if(this.maxSpeed){
	      if(Math.abs(v) > this.maxSpeed){
	        if(v > 0){
	          return this.maxSpeed;
	        }else if(v < 0){
	          return this.maxSpeed;
	        }else{
	          return  0;
	        }
	      }else{
	        return v;
	      }
	    }else{
	      return v;
	    }
	  }

	  /**
	   * Gets this Sprite's current animation frame.
	   * @function
	   * @memberOf Sprite#
	   * @return {AnimationFrame} The current frame of the Animation
	   */
	  getCurrentFrame(){
	    if(this.anim){
	      return this.anim.getCurrentFrame();
	    }
	  }

	  /**
	   * Draws the sprite
	   * @function
	   * @memberOf Sprite#
	   * @param {Context} context The HTML5 drawing context
	   */
	  draw(context){
	    if(this.anim){
	      this.anim.draw(context, this.x, this.y);
	    }
	  }

	  /**
	   * Clones the instance of Sprite it is called upon
	   * @function
	   * @memberOf Sprite#
	   * @return {Sprite} A clone of the Sprite
	   */
	  clone() {
	    return new Sprite({
	      anim: this.anim.clone()
	    });
	  }
	}

	module.exports = Sprite;



/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This type of sprite is based off of the excellent images from Reiner's tilesets: http://www.reinerstilesets.de/
	 * <br>
	 * creatures have walking, idle, and dying animations in 8 isometric directions
	 * The animations directions are in E,N,NE,NW,S,SE,SW,W (alphabetical) order simply because that's
	 * how they were stitched together using ImageMagick.
	 *
	 * @name Creature
	 * @constructor Creature
	 * @extends Sprite
	 */

	const Sprite = __webpack_require__(27);
	const Animation = __webpack_require__(15);


	/**
	* A map of static constants for internal use
	* @type {Object}
	* @memberOf Creature#
	* @property {Number} EAST a direction the creature can face
	* @property {Number} NORTH a direction the creature can face
	* @property {Number} NORTHEAST a direction the creature can face
	* @property {Number} NORTHWEST a direction the creature can face
	* @property {Number} SOUTH a direction the creature can face
	* @property {Number} SOUTHEAST a direction the creature can face
	* @property {Number} SOUTHWEST a direction the creature can face
	* @property {Number} WEST a direction the creature can face
	* @property {Number} STATE_WALKING a state the creature can be in
	* @property {Number} STATE_DYING a state the creature can be in
	* @property {Number} STATE_IDLE a state the creature can be in
	*/
	const EAST = 0;
	const NORTH = 1;
	const NORTHEAST = 2;
	const NORTHWEST = 3;
	const SOUTH = 4;
	const SOUTHEAST = 5;
	const SOUTHWEST = 6;
	const WEST = 7;
	const STATE_WALKING = 0;
	const STATE_DYING = 1;
	const STATE_IDLE = 2;


	class Creature extends Sprite {
	  constructor(options = {}){
	    super(options);

	    /**
	    * The current state of the creature. Will be a value from the static constants.
	    * @type {Number}
	    * @memberOf Creature#
	    * @default
	    */
	    this.state = STATE_IDLE;

	    /**
	    * An array of Animation objects (one for each direction) to display the creature in a walking state
	    * @type {Array}
	    * @memberOf Creature#
	    * @default
	    */
	    this.walkingAnims = [];

	    /**
	    * An array of Animation objects (one for each direction) to display the creature in a dying state
	    * @type {Array}
	    * @memberOf Creature#
	    * @default
	    */
	    this.dyingAnims = [];

	    /**
	    * An array of Animation objects (one for each direction) to display the creature in an idle state
	    * @type {Array}
	    * @memberOf Creature#
	    * @default
	    */
	    this.idleAnims = [];

	    /**
	    * The current direction that the creature is pointed. Will be a value from the static constansts.
	    * @type {Number}
	    * @memberOf Creature#
	    * @default
	    */
	    this.direction = EAST;

	    Object.assign(this, options);
	  }

	  /**
	   * Updates this creature's current direction (frame), and changes which animation it should be using if neccesary.
	   * @function
	   * @memberOf Creature#
	   * @param {Number} elapsedTime Elapsed time in milliseconds
	   */
	  updateDirection(elapsedTime){
	    this.x += this.dx * elapsedTime;
	    this.y += this.dy * elapsedTime;

	    if(this.state !== this.statics.STATE_DYING){
	      if(this.dx > 0 && this.dy === 0){
	        this.direction = this.statics.EAST;
	      } else if(this.dx === 0 && this.dy < 0){
	        this.direction = this.statics.NORTH;
	      } else if(this.dx > 0 && this.dy < 0){
	        this.direction = this.statics.NORTHEAST;
	      } else if(this.dx < 0 && this.dy < 0){
	        this.direction = this.statics.NORTHWEST;
	      } else if(this.dx === 0 && this.dy > 0){
	        this.direction = this.statics.SOUTH;
	      } else if(this.dx > 0 && this.dy > 0){
	        this.direction = this.statics.SOUTHEAST;
	      } else if(this.dx < 0 && this.dy > 0){
	        this.direction = this.statics.SOUTHWEST;
	      } else if(this.dx < 0 && this.dy === 0){
	        this.direction = this.statics.WEST;
	      }

	      if(this.dx === 0 && this.dy === 0){
	        this.state = this.statics.STATE_IDLE;
	      } else {
	        this.state = this.statics.STATE_WALKING;
	      }
	    }
	  }

	  /**
	   * Updates this creature's current animation.
	   * @function
	   * @memberOf Creature#
	   * @param {Number} elapsedTime Elapsed time in milliseconds
	   */
	  updateAnimations(elapsedTime){
	    if(this.state === this.statics.STATE_WALKING){
	      this.anim = this.walkingAnims[this.direction];
	    } else if(this.state === this.statics.STATE_DYING){
	      this.anim = this.dyingAnims[this.direction];
	    } else {
	      this.anim = this.idleAnims[this.direction];
	    }
	    this.anim.update(elapsedTime);
	  }

	  /**
	   * Used to create animations from a sheet of tiles
	   * @function
	   * @memberOf Creature#
	   * @param  {Number} frameCount Number of frames in the animation
	   * @param  {Number|Array} frameTimes Value or array of values corresponding to amount of time per frame
	   * @param  {Image} img Image sheet to create animation from
	   * @param  {Number} w Width of each tile in pixels
	   * @param  {Number} h Height of each tile in pixels
	   * @param  {Number} ySlot Slot on Y axis to start creating tiles
	   * @return {Array} Array of Animations generated using parameters
	   */
	  createAnimations(frameCount, frameTimes, img, h, w, ySlot){
	    var anims = [];
	    var isFTArray = Array.isArray(frameTimes);
	    var currentFrameTime = 1;
	    if(!ySlot){
	      ySlot = 0;
	    }
	    for(var i = 0; i < 8; i++){
	      anims[i] = new Animation({
	        height: h,
	        width: w,
	        image: img
	      });
	      for(var j = 0; j < frameCount; j++){
	        if(isFTArray){
	          currentFrameTime = frameTimes[j];
	        } else {
	          currentFrameTime = frameTimes;
	        }
	        anims[i].addFrame(currentFrameTime, j + frameCount * i, ySlot);
	      }
	    }
	    return anims;
	  }
	}

	module.exports = Creature;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	const Circle = __webpack_require__(30);
	const MultiPolygon = __webpack_require__(32);
	const Polygon = __webpack_require__(33);
	const Rectangle = __webpack_require__(34);

	var entities = {
	  Circle,
	  MultiPolygon,
	  Polygon,
	  Rectangle
	};

	module.exports = entities;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This represents a Circle body and shape in a Box2d world
	 * @name Circle
	 * @constructor Circle
	 * @extends Entity
	 */

	const Entity = __webpack_require__(31);
	const distance = __webpack_require__(22);

	class Circle extends Entity{
	  constructor(options = {}){
	    super(options);

	    /**
	     * The radius of this circle.
	     * @type {Number}
	     * @memberOf Circle#
	     * @default
	     */
	    this.radius = 1;

	    Object.assign(this, options);
	  }

	  /**
	   * Draws the Circle at a given scale
	   * @function
	   * @memberOf Circle#
	   * @param {Context} ctx The drawing context
	   * @param {Number} scale The scale at which to draw
	   */
	  draw(ctx, scale){
	    scale = scale || this.scale || 1;
	    var ogLineWidth = ctx.lineWidth;
	    ctx.lineWidth = this.lineWidth;
	    ctx.fillStyle = this.fillStyle;
	    ctx.strokeStyle = this.strokeStyle;
	    ctx.beginPath();
	    ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, true);
	    ctx.closePath();
	    ctx.fill();
	    ctx.stroke();

	    if(!this.staticBody){
	      ctx.save();
	      ctx.translate(this.x * scale, this.y * scale);
	      ctx.rotate(this.angle);
	      ctx.translate(-(this.x) * scale, -(this.y) * scale);
	      ctx.beginPath();
	      ctx.moveTo(this.x * scale, this.y * scale);
	      ctx.lineTo(this.x * scale, (this.y * scale) - (this.radius * scale));
	      ctx.closePath();
	      ctx.stroke();
	      ctx.restore();
	    }
	    ctx.lineWidth = ogLineWidth;

	    super.draw(ctx, scale);
	  }

	  /**
	   * Scale this shape
	   * @function
	   * @memberOf Circle#
	   * @param {Number} scale The amount the shape should scale
	   */
	  scaleShape(scale){
	    this.radius = this.radius * scale;
	    super.scaleShape(scale);
	  }


	  /**
	   * Checks if a given point is contained within this Circle.
	   * @function
	   * @memberOf Circle#
	   * @param {Object} point An object with x and y values.
	   * @return {Boolean} True if point is in shape else false
	   */
	  pointInShape(point){
	    return (distance(point, this) <= this.radius);
	  }

	}

	module.exports = Circle;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	function genId() {
	  return Math.random() + '_' + Date.now();
	}

	/**
	 * This represents a body and shape in a Box2d world using positions and sizes relative to the Box2d world instance.
	 * @name Entity
	 * @constructor Entity
	 */

	class Entity {
	  constructor(options = {}){

	    /**
	     * The id in which to reference this object. Also the userData property for box2d bodies.
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.id = options.id || genId();

	    /**
	     * The x component of the entity's location
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.x = 0;

	    /**
	     * The y component of the entity's location
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.y = 0;

	    /**
	     * The scale in pixels per meter in which to represent this Entity in the box2d world
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.scale = null;

	    /**
	     * The current angle that this entity is rotated at
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.angle = 0;

	    /**
	     * The x and y locations of what box2d considers the enity's center of mass
	     * @type {Point}
	     * @memberOf Entity#
	     * @default
	     */
	     this.center = null;

	    /**
	     * Whether to draw the center point of an entity
	     * @type {Boolean}
	     * @memberOf Entity#
	     * @default true
	     */
	     this.drawCenter = true;

	    /**
	     * The percentage of force in which the entity will bounce back from another based on its force pre-collision
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.restitution = 0.3;

	    /**
	     * The two-dimensional density of the entity.  Mass / area.
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.density = 1.0;

	    /**
	     * The amount of friction on th surface of this entity
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.friction = 0.9;

	    /**
	     * The amount of linear velocity the entity should lose over time
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.linearDamping = 0;

	    /**
	     * The velocity in meters/second given to this entity by box2d calculations
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.linearVelocity = null;

	    /**
	     * The angular velocity in radians/second given to this entity by box2d calculations
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.angularVelocity = 0;

	    /**
	     * The of amount of angular velocity an entity should lose over time
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.angularDamping = 0;

	    /**
	     * If true, the entity does change its position and angle as the result of box2d calculations
	     * @type {Boolean}
	     * @memberOf Entity#
	     * @default
	     */
	     this.staticBody = false;

	    /**
	     * The fillStyle to use for the entity's default renderer
	     * @type {String}
	     * @memberOf Entity#
	     * @default
	     */
	     this.fillStyle = 'rgba(128,128,128,0.5)';

	    /**
	     * The strokeStyle to use for the entity's default renderer
	     * @type {String}
	     * @memberOf Entity#
	     * @default
	     */
	     this.strokeStyle = '#000';

	    /**
	     * The line width to use for the entity's default renderer
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.lineWidth = 1;

	    /**
	     * The 16 bit integer used in determining which other types of entities this body will collide with.
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.maskBits = null;

	    /**
	     * The 16 bit integer used in describing the type that this enitity is for collisions.
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.categoryBits = null;

	    /**
	     * The 16 bit integer used in overiding maskBits and categoryBits for collision detection.
	     * @type {Number}
	     * @memberOf Entity#
	     * @default
	     */
	     this.groupIndex = null;

	    Object.assign(this, options);
	  }

	  /**
	   * Update this entity with the state passed in
	   * @function
	   * @memberOf Entity#
	   * @param {Object} state State to merge with this object
	   */
	  update(state){
	    Object.assign(this, state);
	  }

	  /**
	   * Draws the Entity at a given scale
	   * @function
	   * @memberOf Entity#
	   * @param {Context} ctx The HTML5 2d drawing context
	   * @param {Number} scale The scale to draw the entity at
	   */
	  draw(ctx, scale){
	    scale = scale || this.scale || 1;
	    var ogLineWidth = ctx.lineWidth;
	    ctx.lineWidth = this.lineWidth;
	    // black circle in entity's location
	    ctx.fillStyle = this.strokeStyle;
	    ctx.beginPath();
	    ctx.arc(this.x * scale, this.y * scale, 4, 0, Math.PI * 2, true);
	    ctx.closePath();
	    ctx.fill();

	    // yellow circle in entity's geometric center
	    if(this.center && this.drawCenter){
	      ctx.fillStyle = this.centerStyle || 'yellow';
	      ctx.beginPath();
	      ctx.arc(this.center.x * scale, this.center.y * scale, 2, 0, Math.PI * 2, true);
	      ctx.closePath();
	      ctx.fill();
	    }

	    ctx.lineWidth = ogLineWidth;
	  }

	  /**
	   * Scales the position and dimensions of this shape.
	   * @function
	   * @memberOf Entity#
	   * @param {Number} scale The scale to multiply the dimentions by
	   */
	  scaleShape(scale){
	    this.x = this.x * scale;
	    this.y = this.y * scale;
	    this.alreadyScaled = true;
	  }
	}

	module.exports = Entity;



/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This Entity is for building complex and possibly concave shapes
	 * @name MultiPolygon
	 * @constructor MultiPolygon
	 * @extends Entity
	 */

	const Entity = __webpack_require__(31);
	const scalePoints = __webpack_require__(25);
	const pointInPolygon = __webpack_require__(21);
	const translatePoints = __webpack_require__(26);

	class MultiPolygon extends Entity {
	  constructor(options = {}){
	    super(options);

	    /**
	     * An array of polygons
	     * @type {Array}
	     * @memberOf MultiPolygon#
	     * @default
	     */
	    this.polys = [];

	    Object.assign(this, options);
	  }

	  /**
	   * Draws each polygon in the entity
	   * @function
	   * @memberOf MultiPolygon#
	   * @param {Context} ctx the HTML5 2d drawing context
	   * @param {Number} scale the scale to draw the entity at
	   */
	  draw(ctx, scale){
	    scale = scale || this.scale || 1;
	    var ogLineWidth = ctx.lineWidth;
	    ctx.lineWidth = this.lineWidth;
	    ctx.save();
	    ctx.translate(this.x * scale, this.y * scale);
	    ctx.rotate(this.angle);
	    ctx.translate(-(this.x) * scale, -(this.y) * scale);
	    ctx.fillStyle = this.fillStyle;
	    ctx.strokeStyle = this.strokeStyle;

	    for(var j = 0; j < this.polys.length; j++){
	      ctx.beginPath();
	      ctx.moveTo((this.x + this.polys[j][0].x) * scale, (this.y + this.polys[j][0].y) * scale);
	      for (var i = 1; i < this.polys[j].length; i++) {
	         ctx.lineTo((this.polys[j][i].x + this.x) * scale, (this.polys[j][i].y + this.y) * scale);
	      }
	      ctx.lineTo((this.x + this.polys[j][0].x) * scale, (this.y + this.polys[j][0].y) * scale);
	      ctx.closePath();
	      ctx.fill();
	      ctx.stroke();
	    }

	    ctx.restore();
	    ctx.lineWidth = ogLineWidth;
	    super.draw(ctx, scale);
	  }

	  /**
	   * Scale this shape
	   * @function
	   * @memberOf MultiPolygon#
	   * @param {Number} scale The amount the shape should scale
	   */
	  scaleShape(scale){
	    this.polys = scalePoints(this.polys, scale);
	    sup.scaleShape(scale);
	  }

	  /**
	   * Checks if a given point is contained within this MultiPolygon.
	   * @function
	   * @memberOf MultiPolygon#
	   * @param {Object} point An object with x and y values.
	   * @return {Boolean} True if point is in shape else false
	   */
	  pointInShape(point){
	    for(var j = 0; j < this.polys.length; j++){
	      if(pointInPolygon(point, translatePoints(this.polys[j], this))){
	        return true;
	      }
	    }
	    return false;
	  }
	}


	module.exports = MultiPolygon;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This Entity represents a polygon which is build from an array of points.
	 * @name Polygon
	 * @constructor Polygon
	 * @extends Entity
	 */

	const Entity = __webpack_require__(31);
	const scalePoints = __webpack_require__(25);
	const pointInPolygon = __webpack_require__(21);
	const translatePoints = __webpack_require__(26);

	class Polygon extends Entity {
	  constructor(options = {}){
	    super(options);

	    /**
	     * An array of objects that have x and y values.
	     * @type {Array}
	     * @memberOf Polygon#
	     * @default
	     */
	    this.points = [];

	    Object.assign(this, options);
	  }

	  /**
	   * Draws the Polygon at a given scale
	   * @function
	   * @memberOf Polygon#
	   * @param {Context} ctx The drawing context
	   * @param {Number} scale The scale at which to draw
	   */
	  draw(ctx, scale){
	    scale = scale || this.scale || 1;
	    var ogLineWidth = ctx.lineWidth;
	    ctx.lineWidth = this.lineWidth;
	    ctx.save();
	    ctx.translate(this.x * scale, this.y * scale);
	    ctx.rotate(this.angle);
	    ctx.translate(-(this.x) * scale, -(this.y) * scale);
	    ctx.fillStyle = this.fillStyle;
	    ctx.strokeStyle = this.strokeStyle;

	    ctx.beginPath();
	    ctx.moveTo((this.x + this.points[0].x) * scale, (this.y + this.points[0].y) * scale);
	    for (var i = 1; i < this.points.length; i++) {
	       ctx.lineTo((this.points[i].x + this.x) * scale, (this.points[i].y + this.y) * scale);
	    }
	    ctx.lineTo((this.x + this.points[0].x) * scale, (this.y + this.points[0].y) * scale);
	    ctx.closePath();
	    ctx.fill();
	    ctx.stroke();

	    ctx.restore();
	    ctx.lineWidth = ogLineWidth;
	    super.draw(ctx, scale);
	  }

	  /**
	   * Scale this shape
	   * @function
	   * @memberOf Polygon#
	   * @param {Number} scale The amount the shape should scale
	   */
	  scaleShape(scale){
	    this.points = scalePoints(this.points, scale);
	    super.scaleShape(scale);
	  }

	  /**
	   * Checks if a given point is contained within this Polygon.
	   * @function
	   * @memberOf Polygon#
	   * @param {Object} point An object with x and y values.
	   * @return {Boolean} True if point is in shape else false
	   */
	  pointInShape(point){
	    return pointInPolygon(point, translatePoints(this.points, this));
	  }
	}

	module.exports = Polygon;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This Entity represents a Rectangle
	 * @name Rectangle
	 * @constructor Rectangle
	 * @extends Entity
	 */

	const Entity = __webpack_require__(31);

	class Rectangle extends Entity {
	  constructor(options = {}){
	    super(options);

	    /**
	     * Half of the Rectangle's total width
	     * @type {Number}
	     * @memberOf Rectangle#
	     * @default
	     */
	    this.halfWidth = 1;
	    /**
	     * Half of the Rectangle's total width
	     * @type {Number}
	     * @memberOf Rectangle#
	     * @default
	     */
	    this.halfHeight = 1;

	    Object.assign(this, options);
	  }

	  /**
	   * Draws the Rectangle at a given scale
	   * @function
	   * @memberOf Rectangle#
	   * @param {Context} ctx The drawing context
	   * @param {Number} scale The scale at which to draw
	   */
	  draw(ctx, scale){
	    scale = scale || this.scale || 1;
	    var ogLineWidth = ctx.lineWidth;
	    ctx.lineWidth = this.lineWidth;
	    ctx.save();
	    ctx.translate(this.x * scale, this.y * scale);
	    ctx.rotate(this.angle);
	    ctx.translate(-(this.x) * scale, -(this.y) * scale);
	    ctx.fillStyle = this.fillStyle;
	    ctx.strokeStyle = this.strokeStyle;
	    ctx.fillRect(
	      (this.x-this.halfWidth) * scale,
	      (this.y-this.halfHeight) * scale,
	      (this.halfWidth*2) * scale,
	      (this.halfHeight*2) * scale
	    );
	    ctx.strokeRect(
	      (this.x-this.halfWidth) * scale,
	      (this.y-this.halfHeight) * scale,
	      (this.halfWidth*2) * scale,
	      (this.halfHeight*2) * scale
	    );
	    ctx.restore();
	    ctx.lineWidth = ogLineWidth;
	    super.draw(ctx, scale);
	  }

	  /**
	   * Scale this shape
	   * @function
	   * @memberOf Rectangle#
	   * @param {Number} scale The amount the shape should scale
	   */
	  scaleShape(scale){
	    this.halfHeight = this.halfHeight * scale;
	    this.halfWidth = this.halfWidth * scale;
	    super.scaleShape(scale);
	  }

	  /**
	   * Checks if a given point is contained within this Rectangle.
	   * @function
	   * @memberOf Rectangle#
	   * @param {Object} point An object with x and y values.
	   * @return {Boolean} True if point is in shape else false
	   */
	  pointInShape(point){
	    return ((point.x >= (this.x - this.halfWidth)) && (point.x <= (this.x + this.halfWidth)) && (point.y >= (this.y - this.halfHeight)) && (point.y <= (this.y + this.halfHeight)));
	  }
	}

	module.exports = Rectangle;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	const Distance = __webpack_require__(36);
	const Prismatic = __webpack_require__(38);
	const Revolute = __webpack_require__(39);

	var joints = {
	  Distance,
	  Prismatic,
	  Revolute
	};

	module.exports = joints;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This represents a distance joint between two bodies.
	 * This type of joint forces two bodies to keep a constant distance for each other.
	 * @name Distance
	 * @constructor Distance
	 * @extends Joint
	 */

	const Joint = __webpack_require__(37);


	// box2d globals
	const B2Vec2 = Box2D.Common.Math.b2Vec2;
	const B2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;

	class Distance extends Joint {
	  constructor(options = {}){
	    super(options);

	    /**
	     * A point on the second entity where the joint will be attached. If no point is specified, the second body will be attached at its center point.
	     * @type {Object}
	     * @memberOf Distance#
	     * @default
	     */
	    this.bodyPoint2 = null;

	    Object.assign(this, options);
	  }

	  /**
	   * Scales the positions bodies that the joint are connected at.
	   * @function
	   * @memberOf Distance#
	   * @param {Number} scale the scale to multiply the dimentions by
	   */
	  scaleJointLocation(scale){
	    if(scale && this.bodyPoint2){
	      this.bodyPoint2.x = this.bodyPoint2.x * scale;
	      this.bodyPoint2.y = this.bodyPoint2.y * scale;
	      this.alreadyScaled = true;
	    }
	    super.scaleJointLocation(scale);
	  }

	  /**
	   * Creates and adds this joint in the Box2d world.
	   * @function
	   * @memberOf Distance#
	   * @param {Box} the box in which to create the joint.
	   * @return {b2Joint} Joint created by box2d
	   */
	  createB2Joint(box){
	    if(box && box.bodiesMap && box.b2World && box.jointsMap && !box.jointsMap[this.id]){
	      const body1 = box.bodiesMap[this.bodyId1];
	      const body2 = box.bodiesMap[this.bodyId2];
	      if(body1 && body2){
	        let vec1, vec2;
	        if(this.bodyPoint1){
	          vec1 = new B2Vec2(this.bodyPoint1.x, this.bodyPoint1.y);
	        }
	        if(this.bodyPoint2){
	          vec2 = new B2Vec2(this.bodyPoint2.x, this.bodyPoint2.y);
	        }
	        vec1 = vec1 || body1.GetWorldCenter();
	        vec2 = vec2 || body2.GetWorldCenter();
	        const joint = new B2DistanceJointDef();
	        joint.Initialize(body1, body2, vec1, vec2);

	        if (this.jointAttributes) {
	          Object.assign(joint, this.jointAttributes);
	        }
	        return box.b2World.CreateJoint(joint);
	      }
	    }
	  }
	}

	module.exports = Distance;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	/**
	 * This represents a joint between two bodies.
	 * @name Joint
	 * @constructor Joint
	 */


	class Joint {
	  constructor(options = {}){

	    /**
	     * The id of the first entity that will be attached to this joint
	     * @type {String}
	     * @memberOf Joint#
	     * @default
	     */
	    this.bodyId1 = null;

	    /**
	     * The id of the second entity that will be attached to this joint
	     * @type {String}
	     * @memberOf Joint#
	     * @default
	     */
	    this.bodyId2 = null;

	    /**
	     * A point on the first entity where be attached to the second body. If no point is specified, the first body will be attached at its center point.
	     * @type {Object}
	     * @memberOf Joint#
	     * @default
	     */
	    this.bodyPoint1 = null;

	    /**
	     * An object with any other properties that should be mixed into the box2d joint definition.
	     * @type {Object}
	     * @memberOf Joint#
	     * @default
	     */
	    this.jointAttributes = null;

	    Object.assign(this, options);
	  }

	  /**
	   * Scales the position that on the first body that the joint is connected at.
	   * @function
	   * @memberOf Joint#
	   * @param {Number} scale the scale to multiply the dimentions by
	   */
	  scaleJointLocation(scale){
	    if(scale && this.bodyPoint1){
	      this.bodyPoint1.x = this.bodyPoint1.x * scale;
	      this.bodyPoint1.y = this.bodyPoint1.y * scale;
	      this.alreadyScaled = true;
	    }
	  }
	}

	module.exports = Joint;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This represents a prismatic joint between two bodies.
	 * This type of joint forces a body to keep its angle rotation consitent with another body
	 * @name Prismatic
	 * @constructor Prismatic
	 * @extends Joint
	 */

	const Joint = __webpack_require__(37);

	// box2d globals
	const B2Vec2 = Box2D.Common.Math.b2Vec2;
	const B2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef;

	class Prismatic extends Joint {
	  constructor(options = {}){
	    super(options);

	    /**
	     * An object with x and y numeric components representing the line in which the entities can move relative to each other
	     * @type {Object}
	     * @memberOf Prismatic#
	     * @default
	     */
	    this.axisScale = null;

	    Object.assign(this, options);
	  }

	  /**
	   * Creates and adds this joint in the Box2d world.
	   * @function
	   * @memberOf Prismatic#
	   * @param {Box} the box in which to create the joint.
	   * @return {b2Joint} Joint created by box2d
	   */
	  createB2Joint(box){
	    if(box && box.bodiesMap && box.b2World && box.jointsMap && !box.jointsMap[this.id]){
	      const body1 = box.bodiesMap[this.bodyId1];
	      const body2 = box.bodiesMap[this.bodyId2];
	      if(body1 && body2){
	        let vec1;
	        if(this.bodyPoint1){
	          vec1 = new B2Vec2(this.bodyPoint1.x, this.bodyPoint1.y);
	        }
	        vec1 = vec1 || body1.GetWorldCenter();
	        var joint = new B2PrismaticJointDef();
	        var axis;
	        if(this.axisScale){
	          axis = new B2Vec2(this.axisScale.x, this.axisScale.y);
	        }else{
	          axis = new B2Vec2(1, 0);
	        }
	        joint.Initialize(body1, body2, vec1, axis);

	        if (this.jointAttributes) {
	          Object.assign(joint, this.jointAttributes);
	        }
	        return box.b2World.CreateJoint(joint);
	      }
	    }
	  }
	}

	module.exports = Prismatic;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This represents a revolute joint between two bodies.
	 * This allow for rotation of one body around a point of another.
	 * @name Revolute
	 * @constructor Revolute
	 * @extends Joint
	 */

	const Joint = __webpack_require__(37);

	// box2d globals
	const B2Vec2 = Box2D.Common.Math.b2Vec2;
	const B2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;


	class Revolute extends Joint {
	  constructor(options = {}){
	    super(options);

	    Object.assign(this, options);
	  }

	  /**
	   * Creates and adds this joint in the Box2d world.
	   * @function
	   * @memberOf Revolute#
	   * @param {Box} the box in which to create the joint.
	   * @return {b2Joint} Joint created by box2d
	   */
	  createB2Joint(box){
	    if(box && box.bodiesMap && box.b2World && box.jointsMap && !box.jointsMap[this.id]){
	        var body1 = box.bodiesMap[this.bodyId1];
	        var body2 = box.bodiesMap[this.bodyId2];
	        if(body1 && body2){
	          var vec1;
	          if(this.bodyPoint1){
	            vec1 = new B2Vec2(this.bodyPoint1.x, this.bodyPoint1.y);
	          }
	          vec1 = vec1 || body1.GetWorldCenter();
	          var joint = new B2RevoluteJointDef();
	          var axis;
	          joint.Initialize(body1, body2, vec1, axis);

	          if (this.jointAttributes) {
	            Object.assign(joint, this.jointAttributes);
	          }
	          return box.b2World.CreateJoint(joint);
	        }
	      }
	    }
	}

	module.exports = Revolute;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * This wraps the box2d world that contains bodies, shapes, and performs the physics calculations.
	 * @name Box
	 * @constructor Box
	 */

	const Contact = __webpack_require__(41);


	console.log(Box2D, 'Box2D', global, window);

	// box2d globals
	var B2Vec2 = Box2D.Common.Math.b2Vec2;
	var B2BodyDef = Box2D.Dynamics.b2BodyDef;
	var B2Body = Box2D.Dynamics.b2Body;
	var B2FixtureDef = Box2D.Dynamics.b2FixtureDef;
	var B2Fixture = Box2D.Dynamics.b2Fixture;
	var B2World = Box2D.Dynamics.b2World;
	var B2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
	var B2CircleShape = Box2D.Collision.Shapes.b2CircleShape;

	class Box {
	  constructor(options = {}){

	    console.log('box', options);

	    /**
	     * The number of cycles per second expected in update calcuations
	     * @type {Number}
	     * @memberOf Box#
	     * @default
	     */
	    this.intervalRate = 60;

	    /**
	     * Whether or not to try to compensate calculations based on performance
	     * @type {Boolean}
	     * @memberOf Box#
	     * @default
	     */
	    this.adaptive = false;

	    /**
	     * A map of the bodies in the box2d world referenced by their given userData
	     * @type {Object}
	     * @memberOf Box#
	     * @default
	     */
	    this.bodiesMap = null;

	    /**
	     * A map of the fixtures in the box2d world referenced by their given userData
	     * @type {Object}
	     * @memberOf Box#
	     * @default
	     */
	    this.fixturesMap = null;

	    /**
	     * A map of the joints in the box2d world referenced by their given userData
	     * @type {Object}
	     * @memberOf Box#
	     * @default
	     */
	    this.jointsMap = null;

	    /**
	     * The instance of the Box2D.Dynamics.b2World world class that the bodies, fixtures, and joints are used in.
	     * @type {B2World}
	     * @memberOf Box#
	     * @default
	     */
	    this.b2World = null;

	    /**
	     * The x component of the b2World's gravity in meters/second squared
	     * @type {Number}
	     * @memberOf Box#
	     * @default
	     */
	    this.gravityX = 0;

	    /**
	     * The y component of the b2World's gravity in meters/second squared
	     * @type {Number}
	     * @memberOf Box#
	     * @default
	     */
	    this.gravityY = 9.8;

	    /**
	     * Allow box2d to skip physics calculations on bodies at rest for performance
	     * @type {Boolean}
	     * @memberOf Box#
	     * @default
	     */
	    this.allowSleep = true;

	    /**
	     * Whether to add a listener to collision events. Default behavior adds collision data to entities on update cycle
	     * @type {Boolean}
	     * @memberOf Box#
	     * @default
	     */
	    this.resolveCollisions = false;

	    /**
	     * A contact listener for callbacks on collision events. Default is this box itself.
	     * @type {Object}
	     * @memberOf Box#
	     * @default
	     */
	    this.contactListener = null;

	    /**
	     * Map of collisions. Instantiated in update if resolveCollisions is true
	     * @type {Object}
	     * @memberOf Box#
	     * @default
	     */
	    this.collisions = null;

	    /**
	     * The number of pixels that represnt one meter in the box2d world. (30 pixels ~ 1 meter in box2d)
	     * @type {Number}
	     * @memberOf Box#
	     * @default
	     */
	    this.scale = 30;

	    this.bodiesMap = {};
	    this.fixturesMap = {};
	    this.jointsMap = {};
	    console.log('firing up b2world', B2World);
	    Object.assign(this, options);

	    this.b2World = new B2World(new B2Vec2(this.gravityX, this.gravityY), this.allowSleep);

	    if(this.intervalRate){
	      this.intervalRate = parseInt(this.intervalRate, 10);
	    }


	    if(this.resolveCollisions){
	      this.contactListener = new Contact();
	    }

	    if(this.contactListener){
	      this.addContactListener(this.contactListener);
	    }

	  }

	  /**
	   * Update the box2d physics calculations
	   * @function
	   * @memberOf Box#
	   * @param  {Number} millis The milliseconds used to determine framerate for box2d step
	   * @return {Number} The amount of milliseconds the update took
	   */
	  update(millis) {
	    // console.log('update millis', millis);

	    if(this.contactListener && this.contactListener.reset){
	      this.contactListener.reset();
	    }

	    var start = Date.now();
	    if(millis){
	      this.b2World.Step(millis / 1000 /* frame-rate */, 10 /* velocity iterations */, 10 /*position iterations*/);
	      this.b2World.ClearForces();
	    }else{
	      var stepRate = (this.adaptive) ? (start - this.lastTimestamp) / 1000 : (1 / this.intervalRate);
	      this.b2World.Step(stepRate /* frame-rate */, 10 /* velocity iterations */, 10 /*position iterations*/);
	      this.b2World.ClearForces();
	    }

	    return (Date.now() - start);
	  }

	  /**
	   * Gets the current state of the objects in the box2d world.
	   * @function
	   * @memberOf Box#
	   * @return {Object} The state of the box2d world
	   */
	  getState() {
	    var state = {};
	      for (var b = this.b2World.GetBodyList(); b; b = b.m_next) {
	        if (b.IsActive() && typeof b.GetUserData() !== 'undefined' && b.GetUserData() !== null) {
	          state[b.GetUserData()] = {
	            x: b.GetPosition().x,
	            y: b.GetPosition().y,
	            angle: b.GetAngle(),
	            center: {
	              x: b.GetWorldCenter().x,
	              y: b.GetWorldCenter().y
	            },
	            linearVelocity: b.m_linearVelocity,
	            angularVelocity: b.m_angularVelocity
	          };
	          if(this.contactListener && this.contactListener.collisions){
	            state[b.GetUserData()].collisions = this.contactListener.collisions[b.GetUserData()] || null;
	          }
	        }
	      }
	      return state;
	  }

	  /**
	   * Updates the state in the Entity objects that are modified by box2d calculations.
	   * @function
	   * @memberOf Box#
	   * @param {Object|Array} entities An array or map of Entity objects
	   */
	  updateExternalState(entities){
	    //update the dyanmic shapes with box2d calculations
	    var bodiesState = this.getState();
	    for (var id in bodiesState) {
	      var entity = entities[id];
	      //update any dynamic bodies
	      if (entity && !entity.staticBody){
	        entity.update(bodiesState[id]);
	      }
	    }
	  }

	  /**
	   * Add a map of entities to the Box
	   * @function
	   * @memberOf Box#
	   * @param {Object} bodyEntities Map of entities
	   */
	  setBodies(bodyEntities) {
	    for(var id in bodyEntities) {
	      var entity = bodyEntities[id];
	      this.addBody(entity);
	    }
	    this.ready = true;
	  }

	  /**
	   * Add an Entity to the box2d world which will internally be converted to a box2d body and fixture (auto scaled with Box's scale property if the entity hasn't been scaled yet)
	   * @function
	   * @memberOf Box#
	   * @param {Entity} entity Any Entity object
	   */
	  addBody(entity) {
	    /*jshint eqnull:true */

	    if(!entity.alreadyScaled){
	      entity.scaleShape(1 / this.scale);
	      entity.scale = this.scale;
	    }

	    var bodyDef = new B2BodyDef();
	    var fixDef = new B2FixtureDef();
	    var i,j,points,vec,vecs;
	    fixDef.restitution = entity.restitution;
	    fixDef.density = entity.density;
	    fixDef.friction = entity.friction;


	    //these three props are for custom collision filtering
	    if(entity.maskBits != null){
	      fixDef.filter.maskBits = entity.maskBits;
	    }
	    if(entity.categoryBits != null){
	      fixDef.filter.categoryBits = entity.categoryBits;
	    }
	    if(entity.groupIndex != null){
	      fixDef.filter.groupIndex = entity.groupIndex;
	    }

	    if(entity.staticBody){
	      bodyDef.type =  B2Body.b2_staticBody;
	    } else {
	      bodyDef.type = B2Body.b2_dynamicBody;
	    }

	    bodyDef.position.x = entity.x;
	    bodyDef.position.y = entity.y;
	    bodyDef.userData = entity.id;
	    bodyDef.angle = entity.angle;
	    bodyDef.linearDamping = entity.linearDamping;
	    bodyDef.angularDamping = entity.angularDamping;
	    var body = this.b2World.CreateBody(bodyDef);


	    if (entity.radius) { //circle
	      fixDef.shape = new B2CircleShape(entity.radius);
	      body.CreateFixture(fixDef);
	    } else if (entity.points) { //polygon
	      points = [];
	      for (i = 0; i < entity.points.length; i++) {
	        vec = new B2Vec2();
	        vec.Set(entity.points[i].x, entity.points[i].y);
	        points[i] = vec;
	      }
	      fixDef.shape = new B2PolygonShape();
	      fixDef.shape.SetAsArray(points, points.length);
	      body.CreateFixture(fixDef);
	    } else if(entity.polys) { //complex object
	        for (j = 0; j < entity.polys.length; j++) {
	            points = entity.polys[j];
	            vecs = [];
	            for (i = 0; i < points.length; i++) {
	                vec = new B2Vec2();
	                vec.Set(points[i].x, points[i].y);
	                vecs[i] = vec;
	            }
	            fixDef.shape = new B2PolygonShape();
	            fixDef.shape.SetAsArray(vecs, vecs.length);
	            body.CreateFixture(fixDef);
	        }
	    } else { //rectangle
	      fixDef.shape = new B2PolygonShape();
	      fixDef.shape.SetAsBox(entity.halfWidth, entity.halfHeight);
	      body.CreateFixture(fixDef);
	    }


	    this.bodiesMap[entity.id] = body;
	  }

	  /**
	   * Set the position of an entity.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} x The new x coordinate in box2d space
	   * @param {Number} y The new y coordinate in box2d space
	   */
	  setPosition(bodyId, x, y){
	    var body = this.bodiesMap[bodyId];
	    body.SetPosition(new B2Vec2(x, y));
	  }

	  /**
	   * Set the angle of an entity.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} angle The new angle of the body in radians
	   */
	  setAngle(bodyId, angle){
	    var body = this.bodiesMap[bodyId];
	    body.setAngle(angle);
	  }

	  /**
	   * Set the linear velocity of an entity.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} x The new x component of the velocity
	   * @param {Number} y The new y component of the velocity
	   */
	  setLinearVelocity(bodyId, x, y){
	    var body = this.bodiesMap[bodyId];
	    body.SetLinearVelocity(new B2Vec2(x, y));
	  }

	  /**
	   * Set the angular velocity of an entity.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} velocity The angular velocity for the body
	   */
	  setAngularVelocity(bodyId, velocity){
	    var body = this.bodiesMap[bodyId];
	    body.SetAngularVelocity(velocity);
	  }

	  /**
	   * Apply an impulse to a body at an angle in degrees
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} degrees The angle in which to apply the impulse.
	   * @param {Number} power The impulse power.
	   */
	  applyImpulseDegrees(bodyId, degrees, power) {
	    var body = this.bodiesMap[bodyId];
	    body.ApplyImpulse(
	      new B2Vec2(Math.sin(degrees * (Math.PI / 180)) * power,
	      Math.cos(degrees * (Math.PI / 180)) * power * -1),
	      body.GetWorldCenter()
	    );
	  }

	  /**
	   * Apply a force to a body at an angle in degrees
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} degrees The angle in which to apply the force.
	   * @param {Number} power The power of the force. (The ability to destroy a planet is insignificant next to this)
	   */
	  applyForceDegrees(bodyId, degrees, power) {
	    var body = this.bodiesMap[bodyId];
	    body.ApplyForce(
	      new B2Vec2(Math.sin(degrees * (Math.PI / 180)) * power,
	      Math.cos(degrees * (Math.PI / 180)) * power * -1),
	      body.GetWorldCenter()
	    );
	  }

	  /**
	   * Apply an impulse to a body at an angle in radians
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} radians The angle in which to apply the impulse.
	   * @param {Number} power The impulse power.
	   */
	  applyImpulse(bodyId, radians, power) {
	    var body = this.bodiesMap[bodyId];
	    body.ApplyImpulse(
	      new B2Vec2(Math.sin(radians) * power,
	      Math.cos(radians) * power * -1),
	      body.GetWorldCenter()
	    );
	  }

	  /**
	   * Apply a force to a body at an angle in radians
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} radians The angle in which to apply the force.
	   * @param {Number} power The power of the force. (The ability to destroy a planet is insignificant next to this)
	   */
	  applyForce(bodyId, radians, power) {
	    var body = this.bodiesMap[bodyId];
	    body.ApplyForce(
	      new B2Vec2(Math.sin(radians) * power,
	      Math.cos(radians) * power * -1),
	      body.GetWorldCenter()
	    );
	  }

	  /**
	   * Apply torque (rotation force) to a body.
	   * Positive values are clockwise, negative values are counter-clockwise.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   * @param {Number} power The power of the torque.
	   */
	  applyTorque(bodyId, power) {
	    var body = this.bodiesMap[bodyId];
	    body.ApplyTorque(power);
	  }

	  /**
	   * Sets the world's gravity
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Object} vector An object with x and y values in meters per second squared.
	   */
	  setGravity(vector) {
	    this.b2World.SetGravity(new B2Vec2(vector.x, vector.y));
	  }

	  /**
	   * Remove a body from the box2d world
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   */
	  removeBody(id) {
	    if(this.bodiesMap[id]){
	      if(this.fixturesMap[id]){
	        this.bodiesMap[id].DestroyFixture(this.fixturesMap[id]);
	      }
	      this.b2World.DestroyBody(this.bodiesMap[id]);
	      //delete this.fixturesMap[id];
	      delete this.bodiesMap[id];
	    }
	  }

	  /**
	   * Wake up a body in the box2d world so that box2d will continue to run calculations on it.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} bodyId The id of the Entity/Body
	   */
	  wakeUpBody(id) {
	    if(this.bodiesMap[id]){
	      this.bodiesMap[id].SetAwake(true);
	    }
	  }

	  /**
	   * Add a contactListener to the b2World
	   * @function
	   * @memberOf Box#
	   * @param {Object} callbacks Object containing a beginContant, endContact and/or preSolve/postSolve keys and callbacks
	   */
	  addContactListener(contactListener){
	    var listener = new Box2D.Dynamics.b2ContactListener();
	    if(contactListener.beginContact){
	      listener.BeginContact = function(contact){
	        contactListener.beginContact(contact.m_fixtureA.m_body.m_userData, contact.m_fixtureB.m_body.m_userData, contact);
	      };
	    }
	    if(contactListener.endContact){
	      listener.EndContact = function(contact){
	        contactListener.endContact(contact.m_fixtureA.m_body.m_userData, contact.m_fixtureB.m_body.m_userData, contact);
	      };
	    }
	    if(contactListener.preSolve){
	      listener.PreSolve = function(contact, oldManifold){
	        contactListener.preSolve(contact.m_fixtureA.m_body.m_userData, contact.m_fixtureB.m_body.m_userData, oldManifold, contact);
	      };
	    }
	    if (contactListener.postSolve){
	      listener.PostSolve = function(contact, impulse){
	        contactListener.postSolve(contact.m_fixtureA.m_body.m_userData, contact.m_fixtureB.m_body.m_userData, impulse, contact);
	      };
	    }
	    this.b2World.SetContactListener(listener);
	  }

	  /**
	   * Remove a joint from the world.
	   *
	   * This must be done outside of the update() iteration, and BEFORE any bodies connected to the joint are removed!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Number} jointId The id of joint to be destroyed.
	   */
	  removeJoint(jointId) {
	    if(this.jointsMap[jointId]){
	      this.b2World.DestroyJoint(this.jointsMap[jointId]);
	      delete this.jointsMap[jointId];
	    }
	  }

	  /**
	   * Add a joint to the box2d world.
	   *
	   * This must be done outside of the update() iteration!
	   *
	   * @function
	   * @memberOf Box#
	   * @param {Joint} A joint definition.
	   */
	  addJoint(joint) {
	    if(joint && joint.id && !this.jointsMap[joint.id]){

	      if(!joint.alreadyScaled && joint.scaleJointLocation){
	        joint.scaleJointLocation(1 / this.scale);
	        joint.scale = this.scale;
	      }

	      var b2Joint = joint.createB2Joint(this);
	      if(b2Joint){
	        this.jointsMap[joint.id] = b2Joint;
	      }
	    }
	  }
	}

	module.exports = Box;


	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * This contact listener for the Box2d world assigns collision objects to entities when they collide.
	 * @name Contact
	 * @constructor Contact
	 */

	class Contact {
	  constructor(options = {}){

	    Object.assign(this, options);

	    this.collisions = this.collisions || {};
	  }

	  /**
	   * Resets the state of the contact listener per iteration of the box world calculations.
	   * @function
	   * @memberOf Contact#
	   */
	  reset(){
	    this.collisions = {};
	  }

	  /**
	   * Called when a box2d collison begins
	   * @function beginContact
	   * @memberOf Contact#
	   * @param {String} idA Id of body A
	   * @param {String} idB Id of body B
	   * @param {b2Contacnt} contact The box2d contact object.
	   */

	  /**
	   * Called when a box2d collison ends
	   * @function endContact
	   * @memberOf Contact#
	   * @param {String} idA Id of body A
	   * @param {String} idB Id of body B
	   * @param {b2Contact} contact The box2d contact object.
	  */

	  /**
	   * Called before a box2d collison is resolved
	   * @function preSolve
	   * @memberOf Contact#
	   * @param {String} idA Id of body A
	   * @param {String} idB Id of body B
	   * @param {Object} oldManifold Old manifold object passed into preSolve listener
	   * @param {b2Contact} contact The box2d contact object.
	  */

	  /**
	   * Called after a box2d collison is resolved
	   * @function
	   * @memberOf Contact#
	   * @param {String} idA Id of body A
	   * @param {String} idB Id of body B
	   * @param {Object} impulse Impulse object passed into postSolve listener
	   * @param {b2Contact} contact The box2d contact object.
	  */
	  postSolve(idA, idB, impulse, contact){
	    this.collisions[idA] = this.collisions[idA] || [];
	    this.collisions[idA].push({id: idB, impulse: impulse.normalImpulses[0]});
	    this.collisions[idB] = this.collisions[idB] || [];
	    this.collisions[idB].push({id: idA, impulse: impulse.normalImpulses[0]});
	  }
	}

	module.exports = Contact;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This is a convenience object that allows for quickly creating a box2d based game.
	 * @name BoxGame
	 * @constructor BoxGame
	 * @extends GameCore
	 */

	const GameCore = __webpack_require__(1);
	const Box = __webpack_require__(40);

	class BoxGame extends GameCore {
	  constructor(options = {}){
	    super(options);
	    console.log('boxgame options', options);
	    /**
	     * The instance of Box used for this game.
	     * @type {Box}
	     * @memberOf BoxGame#
	     * @default
	     */
	    this.box = null;

	    /**
	     * Whether the box should perform calculations during its update cycle
	     * @type {Boolean}
	     * @memberOf BoxGame#
	     * @default
	     */
	    this.boxUpdating = true;

	    /**
	     * A map of Entity objects that are added to the Box
	     * @type {Object}
	     * @memberOf BoxGame#
	     * @default
	     */
	    this.entities = null;

	    /**
	     * A map of Joint objects that are added to the Box
	     * @type {Object}
	     * @memberOf BoxGame#
	     * @default
	     */
	    this.joints = null;

	    Object.assign(this, options);

	    if(!this.box){
	      this.box = new Box(options.boxOptions);
	    }

	    if(!this.entities){
	      this.entities = {};
	    }

	    if(!this.joints){
	      this.joints = {};
	    }

	  }

	  /**
	   * Performs all physics calculations in the Box
	   * @function
	   * @memberOf BoxGame#
	   * @param  {Number} millis The milliseconds that have passed since last iteration of gameLoop
	   */
	  updateBox(millis){
	    if(this.boxUpdating){
	      this.box.update(millis);
	      this.box.updateExternalState(this.entities);
	    }
	  }

	  /**
	   * Adds an Entity object to entities and box
	   * @function
	   * @memberOf BoxGame#
	   * @param {Entity} entity Entity to add
	   */
	  addBody(entity){
	    this.entities[entity.id] = entity;
	    this.box.addBody(entity);
	  }

	  /**
	   * Adds a series of Entity objects to entities and box
	   * @function
	   * @memberOf BoxGame#
	   * @param {Array|Entity} entities Can take an array of Entity objects or any number of Entity objects
	   */
	  addBodies(entities){
	    if(!Array.isArray(entities)) {
	      entities = [entities];
	    }
	    var self = this;
	    entities.forEach((entity) => {
	      this.addBody(entity);
	    });
	  }

	  /**
	   * Removes an Entity object from entities and box
	   * @function
	   * @memberOf BoxGame#
	   * @param  {Entity} entity Entity to remove
	   */
	  removeBody(entity){
	    this.box.removeBody(entity.id);
	    delete this.entities[entity.id];
	  }

	  /**
	   * Removes a series of Entity objects from entities and box
	   * @function
	   * @memberOf BoxGame#
	   * @param {Array|Entity} entities Can take an array of Entity objects or any number of Entity objects
	   */
	  removeBodies(entities){
	    if(!Array.isArray(entities)) {
	      entities = [entities];
	    }
	    entities.forEach((entity) => {
	      this.removeBody(entity);
	    });
	  }

	  /**
	   * Adds a Joint to joints and box
	   * @function
	   * @memberOf BoxGame#
	   * @param {Joint} joint Joint to add
	   */
	  addJoint(joint){
	    this.joints[joint.id] = joint;
	    this.box.addJoint(joint);
	  }

	  /**
	   * Adds a series of Joint objects to joints and box
	   * @function
	   * @memberOf BoxGame#
	   * @param {Array|Joint} joints Can take an array of Joint objects or any number of Joint objects
	   */
	  addJoints(joints){
	    if(!Array.isArray(joints)) {
	      joints = [joints];
	    }
	    joints.forEach((entity) => {
	      this.addJoint(entity);
	    });
	  }

	  /**
	   * Removes a Joint from joints and box
	   * @function
	   * @memberOf BoxGame#
	   * @param  {Joint} joint Joint to remove
	   */
	  removeJoint(joint){
	    this.box.removeJoint(joint.id);
	    delete this.joints[joint.id];
	  }

	  /**
	   * Removes a series of Joint objects from joints and box
	   * @function
	   * @memberOf BoxGame#
	   * @param {Array|Joint} joints Can take an array of Joint objects or any number of Joint objects
	   */
	  removeJoints(joints){
	    if(!Array.isArray(joints)) {
	      joints = [joints];
	    }
	    joints.forEach((entity) => {
	      this.removeJoint(entity);
	    });
	  }
	}

	module.exports = BoxGame;



/***/ })
/******/ ]);